Conflict in state 114 between rule 13 and token CHOP resolved as reduce.
Conflict in state 114 between rule 13 and token OR resolved as reduce.
Conflict in state 114 between rule 13 and token AND resolved as reduce.
Conflict in state 114 between rule 13 and token IFF resolved as reduce.
Conflict in state 114 between rule 13 and token PROPIMPLY resolved as reduce.
Conflict in state 114 between rule 13 and token CHOPSTAR resolved as an error.
Conflict in state 115 between rule 21 and token CHOP resolved as reduce.
Conflict in state 115 between rule 21 and token OR resolved as reduce.
Conflict in state 115 between rule 21 and token AND resolved as reduce.
Conflict in state 115 between rule 21 and token IFF resolved as reduce.
Conflict in state 115 between rule 21 and token PROPIMPLY resolved as reduce.
Conflict in state 115 between rule 21 and token CHOPSTAR resolved as an error.
Conflict in state 122 between rule 20 and token CHOP resolved as reduce.
Conflict in state 122 between rule 20 and token OR resolved as reduce.
Conflict in state 122 between rule 20 and token AND resolved as reduce.
Conflict in state 122 between rule 20 and token IFF resolved as reduce.
Conflict in state 122 between rule 20 and token PROPIMPLY resolved as reduce.
Conflict in state 122 between rule 20 and token CHOPSTAR resolved as an error.
Conflict in state 123 between rule 10 and token CHOP resolved as reduce.
Conflict in state 123 between rule 10 and token OR resolved as reduce.
Conflict in state 123 between rule 10 and token AND resolved as reduce.
Conflict in state 123 between rule 10 and token IFF resolved as reduce.
Conflict in state 123 between rule 10 and token PROPIMPLY resolved as reduce.
Conflict in state 123 between rule 10 and token CHOPSTAR resolved as an error.
Conflict in state 124 between rule 9 and token CHOP resolved as reduce.
Conflict in state 124 between rule 9 and token OR resolved as reduce.
Conflict in state 124 between rule 9 and token AND resolved as reduce.
Conflict in state 124 between rule 9 and token IFF resolved as reduce.
Conflict in state 124 between rule 9 and token PROPIMPLY resolved as reduce.
Conflict in state 124 between rule 9 and token CHOPSTAR resolved as an error.
Conflict in state 125 between rule 19 and token CHOP resolved as reduce.
Conflict in state 125 between rule 19 and token OR resolved as reduce.
Conflict in state 125 between rule 19 and token AND resolved as reduce.
Conflict in state 125 between rule 19 and token IFF resolved as reduce.
Conflict in state 125 between rule 19 and token PROPIMPLY resolved as reduce.
Conflict in state 125 between rule 19 and token CHOPSTAR resolved as an error.
Conflict in state 126 between rule 12 and token CHOP resolved as reduce.
Conflict in state 126 between rule 12 and token OR resolved as reduce.
Conflict in state 126 between rule 12 and token AND resolved as reduce.
Conflict in state 126 between rule 12 and token IFF resolved as reduce.
Conflict in state 126 between rule 12 and token PROPIMPLY resolved as reduce.
Conflict in state 126 between rule 12 and token CHOPSTAR resolved as an error.
Conflict in state 127 between rule 11 and token CHOP resolved as reduce.
Conflict in state 127 between rule 11 and token OR resolved as reduce.
Conflict in state 127 between rule 11 and token AND resolved as reduce.
Conflict in state 127 between rule 11 and token IFF resolved as reduce.
Conflict in state 127 between rule 11 and token PROPIMPLY resolved as reduce.
Conflict in state 127 between rule 11 and token CHOPSTAR resolved as an error.
Conflict in state 238 between rule 8 and token CHOP resolved as reduce.
Conflict in state 238 between rule 8 and token OR resolved as shift.
Conflict in state 238 between rule 8 and token AND resolved as shift.
Conflict in state 238 between rule 8 and token IFF resolved as shift.
Conflict in state 238 between rule 8 and token PROPIMPLY resolved as shift.
Conflict in state 238 between rule 8 and token CHOPSTAR resolved as shift.
Conflict in state 239 between rule 5 and token CHOP resolved as reduce.
Conflict in state 239 between rule 5 and token OR resolved as reduce.
Conflict in state 239 between rule 5 and token AND resolved as shift.
Conflict in state 239 between rule 5 and token IFF resolved as shift.
Conflict in state 239 between rule 5 and token PROPIMPLY resolved as shift.
Conflict in state 239 between rule 5 and token CHOPSTAR resolved as shift.
Conflict in state 240 between rule 4 and token CHOP resolved as reduce.
Conflict in state 240 between rule 4 and token OR resolved as reduce.
Conflict in state 240 between rule 4 and token AND resolved as reduce.
Conflict in state 240 between rule 4 and token IFF resolved as shift.
Conflict in state 240 between rule 4 and token PROPIMPLY resolved as shift.
Conflict in state 240 between rule 4 and token CHOPSTAR resolved as shift.
Conflict in state 241 between rule 6 and token CHOP resolved as reduce.
Conflict in state 241 between rule 6 and token OR resolved as reduce.
Conflict in state 241 between rule 6 and token AND resolved as reduce.
Conflict in state 241 between rule 6 and token IFF resolved as reduce.
Conflict in state 241 between rule 6 and token PROPIMPLY resolved as reduce.
Conflict in state 241 between rule 6 and token CHOPSTAR resolved as shift.
Conflict in state 242 between rule 7 and token CHOP resolved as reduce.
Conflict in state 242 between rule 7 and token OR resolved as reduce.
Conflict in state 242 between rule 7 and token AND resolved as reduce.
Conflict in state 242 between rule 7 and token IFF resolved as reduce.
Conflict in state 242 between rule 7 and token PROPIMPLY resolved as reduce.
Conflict in state 242 between rule 7 and token CHOPSTAR resolved as shift.
Conflict in state 301 between rule 33 and token CHOP resolved as reduce.
Conflict in state 301 between rule 33 and token OR resolved as shift.
Conflict in state 301 between rule 33 and token PARALLEL resolved as shift.
Conflict in state 301 between rule 33 and token AND resolved as shift.
Conflict in state 302 between rule 30 and token CHOP resolved as reduce.
Conflict in state 302 between rule 30 and token OR resolved as reduce.
Conflict in state 302 between rule 30 and token PARALLEL resolved as reduce.
Conflict in state 302 between rule 30 and token AND resolved as shift.
Conflict in state 303 between rule 32 and token CHOP resolved as reduce.
Conflict in state 303 between rule 32 and token OR resolved as reduce.
Conflict in state 303 between rule 32 and token PARALLEL resolved as reduce.
Conflict in state 303 between rule 32 and token AND resolved as shift.
Conflict in state 304 between rule 29 and token CHOP resolved as reduce.
Conflict in state 304 between rule 29 and token OR resolved as reduce.
Conflict in state 304 between rule 29 and token PARALLEL resolved as reduce.
Conflict in state 304 between rule 29 and token AND resolved as reduce.
Conflict in state 307 between rule 107 and token BOOL_AND resolved as shift.
Conflict in state 310 between rule 113 and token ADDRESS resolved as shift.
Conflict in state 311 between rule 115 and token NE resolved as shift.
Conflict in state 311 between rule 115 and token EQ resolved as shift.
Conflict in state 312 between rule 118 and token GE resolved as shift.
Conflict in state 312 between rule 118 and token LE resolved as shift.
Conflict in state 312 between rule 118 and token GT resolved as shift.
Conflict in state 312 between rule 118 and token LT resolved as shift.
Conflict in state 313 between rule 117 and token GE resolved as shift.
Conflict in state 313 between rule 117 and token LE resolved as shift.
Conflict in state 313 between rule 117 and token GT resolved as shift.
Conflict in state 313 between rule 117 and token LT resolved as shift.
Conflict in state 314 between rule 121 and token LST resolved as shift.
Conflict in state 314 between rule 121 and token RST resolved as shift.
Conflict in state 315 between rule 123 and token LST resolved as shift.
Conflict in state 315 between rule 123 and token RST resolved as shift.
Conflict in state 316 between rule 120 and token LST resolved as shift.
Conflict in state 316 between rule 120 and token RST resolved as shift.
Conflict in state 317 between rule 122 and token LST resolved as shift.
Conflict in state 317 between rule 122 and token RST resolved as shift.
Conflict in state 318 between rule 125 and token ADD resolved as shift.
Conflict in state 318 between rule 125 and token SUB resolved as shift.
Conflict in state 319 between rule 126 and token ADD resolved as shift.
Conflict in state 319 between rule 126 and token SUB resolved as shift.
Conflict in state 320 between rule 128 and token MUL resolved as shift.
Conflict in state 320 between rule 128 and token DIV resolved as shift.
Conflict in state 320 between rule 128 and token MOD resolved as shift.
Conflict in state 321 between rule 129 and token MUL resolved as shift.
Conflict in state 321 between rule 129 and token DIV resolved as shift.
Conflict in state 321 between rule 129 and token MOD resolved as shift.
State 41 contains 1 shift/reduce conflict.
State 82 contains 1 shift/reduce conflict.
State 83 contains 1 shift/reduce conflict.
State 84 contains 1 shift/reduce conflict.
State 85 contains 1 shift/reduce conflict.
State 86 contains 1 shift/reduce conflict.
State 87 contains 2 shift/reduce conflicts.
State 88 contains 4 shift/reduce conflicts.
State 89 contains 2 shift/reduce conflicts.
State 90 contains 2 shift/reduce conflicts.
State 91 contains 3 shift/reduce conflicts.
State 93 contains 4 shift/reduce conflicts.
State 155 contains 1 shift/reduce conflict.
State 158 contains 1 shift/reduce conflict.
State 159 contains 1 shift/reduce conflict.
State 179 contains 4 shift/reduce conflicts.
State 195 contains 2 shift/reduce conflicts.
State 273 contains 1 shift/reduce conflict.
State 300 contains 5 shift/reduce conflicts.
State 301 contains 1 shift/reduce conflict.
State 302 contains 1 shift/reduce conflict.
State 303 contains 1 shift/reduce conflict.
State 304 contains 1 shift/reduce conflict.
State 308 contains 1 shift/reduce conflict.
State 309 contains 1 shift/reduce conflict.
State 341 contains 1 shift/reduce conflict.
State 386 contains 1 shift/reduce conflict.
State 387 contains 1 shift/reduce conflict.
State 428 contains 1 shift/reduce conflict.
State 429 contains 1 shift/reduce conflict.
State 467 contains 1 shift/reduce conflict.
State 508 contains 1 shift/reduce conflict.
State 509 contains 1 shift/reduce conflict.
State 517 contains 1 shift/reduce conflict.

Grammar
rule 1    program -> gComplexProposition statement
rule 2    gComplexProposition -> PBEGIN complexProposition PEND
rule 3    gComplexProposition ->		/* empty */
rule 4    complexProposition -> complexProposition AND complexProposition
rule 5    complexProposition -> complexProposition OR complexProposition
rule 6    complexProposition -> complexProposition IFF complexProposition
rule 7    complexProposition -> complexProposition PROPIMPLY complexProposition
rule 8    complexProposition -> complexProposition CHOP complexProposition
rule 9    complexProposition -> ALWAYS complexProposition
rule 10   complexProposition -> KEEP complexProposition
rule 11   complexProposition -> SOMETIMES complexProposition
rule 12   complexProposition -> W_NEXT complexProposition
rule 13   complexProposition -> NEXT complexProposition
rule 14   complexProposition -> SKIP
rule 15   complexProposition -> MY_TRUE
rule 16   complexProposition -> MY_FALSE
rule 17   complexProposition -> LENGTH ari_exp
rule 18   complexProposition -> EMPTY
rule 19   complexProposition -> HALT complexProposition
rule 20   complexProposition -> FINAL complexProposition
rule 21   complexProposition -> NEGATION complexProposition
rule 22   complexProposition -> OPEN_BPAR complexProposition poptional_projection CLOSE_BPAR PROJECTION OPEN_BPAR complexProposition CLOSE_BPAR
rule 23   complexProposition -> ID
rule 24   complexProposition -> DEFINE ID COLON ari_exp
rule 25   complexProposition -> complexProposition CHOPSTAR
rule 26   complexProposition -> OPEN_PAR complexProposition CLOSE_PAR
rule 27   poptional_projection -> COMMA complexProposition poptional_projection
rule 28   poptional_projection ->		/* empty */
rule 29   statement -> statement AND statement
rule 30   statement -> statement OR statement
rule 31   statement -> statement ARRAY statement
rule 32   statement -> statement PARALLEL statement
rule 33   statement -> statement CHOP statement
rule 34   statement -> INCLUDE STRLITERAL
rule 35   statement -> EXTERN declaration
rule 36   statement -> EXTERN FUNCTION ID OPEN_PAR func_formal_par CLOSE_PAR
rule 37   statement -> exp
rule 38   statement -> declaration
rule 39   statement -> ass_statement
rule 40   statement -> SKIP
rule 41   statement -> EMPTY
rule 42   statement -> TRUE
rule 43   statement -> FALSE
rule 44   statement -> struct_define_statement
rule 45   statement -> input_statement
rule 46   statement -> output_statement
rule 47   statement -> if_statement
rule 48   statement -> while_statement
rule 49   statement -> do_while_statement
rule 50   statement -> for_statement
rule 51   statement -> extend_for_statement
rule 52   statement -> NEXT OPEN_PAR statement CLOSE_PAR
rule 53   statement -> KEEP OPEN_PAR statement CLOSE_PAR
rule 54   statement -> ALWAYS OPEN_PAR statement CLOSE_PAR
rule 55   statement -> AWAIT OPEN_PAR bool_exp CLOSE_PAR
rule 56   statement -> REPEAT OPEN_BPAR statement CLOSE_BPAR UNTIL OPEN_PAR bool_exp CLOSE_PAR
rule 57   statement -> LENGTH OPEN_PAR ari_exp CLOSE_PAR
rule 58   statement -> FINAL OPEN_PAR statement CLOSE_PAR
rule 59   statement -> FRAME OPEN_PAR exp option_exp CLOSE_PAR AND OPEN_PAR statement CLOSE_PAR
rule 60   statement -> OPEN_BPAR leftpart_4prj optional_projection CLOSE_BPAR PROJECTION OPEN_BPAR statement CLOSE_BPAR
rule 61   statement -> EXIST identifier inner_func_formal_par COLON OPEN_BPAR statement CLOSE_BPAR
rule 62   statement -> FUNCTION ID OPEN_PAR func_formal_par CLOSE_PAR OPEN_BPAR statement CLOSE_BPAR
rule 63   statement -> OPEN_PAR statement CLOSE_PAR
rule 64   leftpart_4prj -> statement
rule 65   leftpart_4prj -> OPEN_PAR statement CLOSE_PAR XOR ari_exp
rule 66   leftpart_4prj -> OPEN_PAR leftpart_4prj optional_leftpart_4prj CLOSE_PAR XOR ari_exp
rule 67   optional_leftpart_4prj ->		/* empty */
rule 68   optional_leftpart_4prj -> COMMA leftpart_4prj optional_leftpart_4prj
rule 69   optional_projection ->		/* empty */
rule 70   optional_projection -> COMMA leftpart_4prj optional_projection
rule 71   optional_projection -> COMMA error
rule 72   struct_define_statement -> struct_identifier OPEN_BPAR option_struct_declaration CLOSE_BPAR
rule 73   option_struct_declaration -> declaration
rule 74   option_struct_declaration -> declaration AND option_struct_declaration
rule 75   struct_identifier -> STRUCT ID
rule 76   struct_identifier -> UNION ID
rule 77   declaration -> basic_type option_declaration
rule 78   declaration -> STRUCT_TYPE option_declaration
rule 79   declaration -> STRUCT ID option_declaration
rule 80   declaration -> UNION ID option_declaration
rule 81   declaration -> STRUCT STRUCT_TYPE option_declaration
rule 82   declaration -> UNION STRUCT_TYPE option_declaration
rule 83   declaration -> VOID OPEN_PAR unary_exp CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR
rule 84   option_declaration -> identifier inner_option_declaration
rule 85   option_declaration -> identifier OPEN_MPAR exp option_exp CLOSE_MPAR inner_option_declaration
rule 86   option_declaration -> identifier ASS_P bool_exp inner_option_declaration
rule 87   option_declaration -> identifier ASS_P init_list inner_option_declaration
rule 88   option_declaration -> identifier ARRAY ASS_P init_list inner_option_declaration
rule 89   option_declaration -> identifier ARRAY ASS_P strliteral inner_option_declaration
rule 90   option_declaration -> identifier OPEN_MPAR exp option_exp CLOSE_MPAR ASS_P init_list inner_option_declaration
rule 91   option_declaration -> identifier OPEN_MPAR exp option_exp CLOSE_MPAR ASS_P strliteral inner_option_declaration
rule 92   option_declaration -> MUL option_declaration
rule 93   option_declaration -> OPEN_PAR MUL identifier CLOSE_PAR OPEN_MPAR exp option_exp CLOSE_MPAR inner_option_declaration
rule 94   inner_option_declaration -> COMMA option_declaration
rule 95   inner_option_declaration -> COMMA error
rule 96   inner_option_declaration ->		/* empty */
rule 97   init_list -> OPEN_BPAR init_exp CLOSE_BPAR
rule 98   init_exp -> bool_exp option_init_exp
rule 99   init_exp -> init_list option_init_exp
rule 100  option_init_exp -> COMMA init_exp
rule 101  option_init_exp ->		/* empty */
rule 102  ass_statement -> unary_exp assign_operator exp
rule 103  assign_operator -> ASS_P
rule 104  assign_operator -> ASS_N
rule 105  exp -> bool_exp
rule 106  bool_exp -> logic_and_exp
rule 107  bool_exp -> bool_exp BOOL_OR logic_and_exp
rule 108  logic_and_exp -> bit_or_exp
rule 109  logic_and_exp -> logic_and_exp BOOL_AND bit_or_exp
rule 110  bit_or_exp -> bit_xor_exp
rule 111  bit_or_exp -> bit_or_exp INTER_OR bit_xor_exp
rule 112  bit_xor_exp -> bit_and_exp
rule 113  bit_xor_exp -> bit_xor_exp XOR bit_and_exp
rule 114  bit_and_exp -> equlity_exp
rule 115  bit_and_exp -> bit_and_exp ADDRESS equlity_exp
rule 116  equlity_exp -> relation_exp
rule 117  equlity_exp -> equlity_exp EQ relation_exp
rule 118  equlity_exp -> equlity_exp NE relation_exp
rule 119  relation_exp -> ari_exp
rule 120  relation_exp -> relation_exp GT ari_exp
rule 121  relation_exp -> relation_exp GE ari_exp
rule 122  relation_exp -> relation_exp LT ari_exp
rule 123  relation_exp -> relation_exp LE ari_exp
rule 124  ari_exp -> add_exp
rule 125  ari_exp -> ari_exp LST add_exp
rule 126  ari_exp -> ari_exp RST add_exp
rule 127  add_exp -> mul_exp
rule 128  add_exp -> add_exp ADD mul_exp
rule 129  add_exp -> add_exp SUB mul_exp
rule 130  mul_exp -> unary_exp
rule 131  mul_exp -> mul_exp MUL unary_exp
rule 132  mul_exp -> mul_exp DIV unary_exp
rule 133  mul_exp -> mul_exp MOD unary_exp
rule 134  unary_exp -> basic_exp
rule 135  unary_exp -> ADDRESS unary_exp
rule 136  unary_exp -> MUL unary_exp
rule 137  unary_exp -> SUB unary_exp
rule 138  unary_exp -> NEGATION unary_exp
rule 139  unary_exp -> BNE unary_exp
rule 140  unary_exp -> SIZEOF OPEN_PAR basic_type CLOSE_PAR
rule 141  unary_exp -> SIZEOF OPEN_PAR basic_type pointer CLOSE_PAR
rule 142  unary_exp -> SIZEOF OPEN_PAR STRUCT_TYPE CLOSE_PAR
rule 143  unary_exp -> SIZEOF OPEN_PAR STRUCT_TYPE pointer CLOSE_PAR
rule 144  unary_exp -> SIZEOF OPEN_PAR bool_exp CLOSE_PAR
rule 145  unary_exp -> type_cast unary_exp
rule 146  unary_exp -> NEXT unary_exp
rule 147  basic_exp -> primary_exp
rule 148  basic_exp -> basic_exp DOT identifier
rule 149  basic_exp -> basic_exp IMPLY identifier
rule 150  basic_exp -> basic_exp OPEN_PAR func_actual_par CLOSE_PAR
rule 151  basic_exp -> EXTERN basic_exp
rule 152  basic_exp -> basic_exp OPEN_MPAR exp option_exp CLOSE_MPAR
rule 153  primary_exp -> const_exp
rule 154  primary_exp -> identifier
rule 155  primary_exp -> OPEN_PAR exp CLOSE_PAR
rule 156  primary_exp -> IF exp THEN exp ELSE exp
rule 157  const_exp -> intliteral
rule 158  const_exp -> charliteral
rule 159  const_exp -> floatliteral
rule 160  const_exp -> strliteral
rule 161  const_exp -> MY_TRUE
rule 162  const_exp -> MY_FALSE
rule 163  const_exp -> POINTERNULL
rule 164  identifier -> ID
rule 165  identifier -> OPEN_PAR identifier CLOSE_PAR
rule 166  type_cast -> OPEN_PAR basic_type CLOSE_PAR
rule 167  type_cast -> OPEN_PAR basic_type pointer CLOSE_PAR
rule 168  type_cast -> OPEN_PAR STRUCT_TYPE CLOSE_PAR
rule 169  type_cast -> OPEN_PAR STRUCT_TYPE pointer CLOSE_PAR
rule 170  type_cast -> OPEN_PAR VOID OPEN_PAR pointer CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR CLOSE_PAR
rule 171  pointer -> MUL
rule 172  pointer -> MUL pointer
rule 173  option_exp -> COMMA exp option_exp
rule 174  option_exp ->		/* empty */
rule 175  basic_type -> VOID
rule 176  basic_type -> BOOL
rule 177  basic_type -> CHAR
rule 178  basic_type -> SIGNED CHAR
rule 179  basic_type -> UNSIGNED CHAR
rule 180  basic_type -> SHORT
rule 181  basic_type -> SIGNED SHORT
rule 182  basic_type -> UNSIGNED SHORT
rule 183  basic_type -> INT
rule 184  basic_type -> SIGNED INT
rule 185  basic_type -> UNSIGNED INT
rule 186  basic_type -> LONG
rule 187  basic_type -> SIGNED LONG
rule 188  basic_type -> UNSIGNED LONG
rule 189  basic_type -> LONG LONG
rule 190  basic_type -> SIGNED LONG LONG
rule 191  basic_type -> UNSIGNED LONG LONG
rule 192  basic_type -> FLOAT
rule 193  basic_type -> DOUBLE
rule 194  basic_type -> STR
rule 195  basic_type -> FILEDEC
rule 196  basic_type -> windows_type
rule 197  windows_type -> CRITICAL_SECTION
rule 198  windows_type -> TIMECAPS
rule 199  func_formal_par -> basic_type option_formal_par inner_func_formal_par
rule 200  func_formal_par -> STRUCT_TYPE option_formal_par inner_func_formal_par
rule 201  func_formal_par -> STRUCT ID option_formal_par inner_func_formal_par
rule 202  func_formal_par -> STRUCT STRUCT_TYPE option_formal_par inner_func_formal_par
rule 203  func_formal_par -> VOID OPEN_PAR unary_exp CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR inner_func_formal_par
rule 204  func_formal_par -> VOID OPEN_PAR unary_exp ARRAY CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR inner_func_formal_par
rule 205  func_formal_par ->		/* empty */
rule 206  option_formal_par -> identifier
rule 207  option_formal_par -> basic_exp OPEN_MPAR exp option_exp CLOSE_MPAR
rule 208  option_formal_par -> basic_exp ARRAY
rule 209  option_formal_par -> MUL option_formal_par
rule 210  option_formal_par ->		/* empty */
rule 211  inner_func_formal_par -> COMMA func_formal_par
rule 212  inner_func_formal_par ->		/* empty */
rule 213  func_actual_par -> exp option_exp
rule 214  func_actual_par ->		/* empty */
rule 215  bool_par -> OPEN_PAR exp CLOSE_PAR
rule 216  bool_par -> error CLOSE_PAR
rule 217  strliteral -> STRLITERAL
rule 218  intliteral -> INTLITERAL
rule 219  charliteral -> CHARLITERAL
rule 220  floatliteral -> FLOATLITERAL
rule 221  while_statement -> WHILE bool_par OPEN_BPAR statement CLOSE_BPAR
rule 222  do_while_statement -> DO OPEN_BPAR statement CLOSE_BPAR WHILE bool_par
rule 223  for_statement -> FOR ari_exp TIMES DO OPEN_BPAR statement CLOSE_BPAR
rule 224  extend_for_statement -> FOR OPEN_PAR for_sta_init COMMA for_sta_condition COMMA for_sta_control CLOSE_PAR OPEN_BPAR statement CLOSE_BPAR
rule 225  for_sta_init -> ass_statement
rule 226  for_sta_init -> declaration
rule 227  for_sta_init ->		/* empty */
rule 228  for_sta_condition -> bool_exp
rule 229  for_sta_condition ->		/* empty */
rule 230  for_sta_control -> ass_statement
rule 231  for_sta_control ->		/* empty */
rule 232  if_statement -> IF exp THEN OPEN_BPAR statement CLOSE_BPAR option_else_statement
rule 233  option_else_statement -> ELSE OPEN_BPAR statement CLOSE_BPAR
rule 234  option_else_statement ->		/* empty */
rule 235  output_statement -> DISPLAY OPEN_PAR exp option_exp CLOSE_PAR
rule 236  input_statement -> REQUEST OPEN_PAR exp option_exp CLOSE_PAR

Terminals, with rules where they appear

$ (-1)
error (256) 71 95 216
INCLUDE (258) 34
IF (259) 156 232
ELSE (260) 156 233
EMPTY (261) 18 41
AWAIT (262) 55
PROJECTION (263) 22 60
PBEGIN (264) 2
PEND (265) 2
POINTERNULL (266) 163
ARRAY (267) 31 88 89 204 208
STRUCT (268) 75 79 81 201 202
DOT (269) 148
UNION (270) 76 80 82
FILEDEC (271) 195
DEFINE (272) 24
MY_TRUE (273) 15 161
MY_FALSE (274) 16 162
EXIST (275) 61
FRAME (276) 59
FOR (277) 223 224
WHILE (278) 221 222
DO (279) 222 223
TRUE (280) 42
FALSE (281) 43
REPEAT (282) 56
UNTIL (283) 56
DISPLAY (284) 235
SKIP (285) 14 40
THEN (286) 156 232
COLON (287) 24 61
VOID (288) 83 170 175 203 204
BOOL (289) 176
CHAR (290) 177 178 179
SHORT (291) 180 181 182
INT (292) 183 184 185
LONG (293) 186 187 188 189 190 191
STR (294) 194
FLOAT (295) 192
DOUBLE (296) 193
CRITICAL_SECTION (297) 197
TIMECAPS (298) 198
OPEN_PAR (299) 26 36 52 53 54 55 56 57 58 59 62 63 65 66 83 93 140
    141 142 143 144 150 155 165 166 167 168 169 170 203 204 215 224
    235 236
CLOSE_PAR (300) 26 36 52 53 54 55 56 57 58 59 62 63 65 66 83 93 140
    141 142 143 144 150 155 165 166 167 168 169 170 203 204 215 216
    224 235 236
TIMES (301) 223
OPEN_BPAR (302) 22 56 60 61 62 72 97 221 222 223 224 232 233
CLOSE_BPAR (303) 22 56 60 61 62 72 97 221 222 223 224 232 233
OPEN_MPAR (304) 85 90 91 93 152 207
CLOSE_MPAR (305) 85 90 91 93 152 207
FUNCTION (306) 36 62
INTER_OR (307) 111
UNSIGNED (308) 179 182 185 188 191
SIGNED (309) 178 181 184 187 190
SIZEOF (310) 140 141 142 143 144
EXTERN (311) 35 36 151
COMMA (312) 27 68 70 71 94 95 100 173 211 224
CHOP (313) 8 33
OR (314) 5 30
PARALLEL (315) 32
AND (316) 4 29 59 74
ASS_P (317) 86 87 88 89 90 91 103
ASS_N (318) 104
BOOL_OR (319) 107
BOOL_AND (320) 109
XOR (321) 65 66 113
ADDRESS (322) 115 135
NE (323) 118
EQ (324) 117
GE (325) 121
LE (326) 123
GT (327) 120
LT (328) 122
LST (329) 125
RST (330) 126
ADD (331) 128
SUB (332) 129 137
MUL (333) 92 93 131 136 171 172 209
DIV (334) 132
MOD (335) 133
BNE (336) 139
IMPLY (337) 149
IFF (338) 6
PROPIMPLY (339) 7
CHOPSTAR (340) 25
NEXT (341) 13 52 146
NEGATION (342) 21 138
LENGTH (343) 17 57
REQUEST (344) 236
FINAL (345) 20 58
KEEP (346) 10 53
ALWAYS (347) 9 54
HALT (348) 19
W_NEXT (349) 12
SOMETIMES (350) 11
ID (351) 23 24 36 62 75 76 79 80 164 201
STRLITERAL (352) 34 217
STRUCT_TYPE (353) 78 81 82 142 143 168 169 200 202
INTLITERAL (354) 218
FLOATLITERAL (355) 220
CHARLITERAL (356) 219

Nonterminals, with rules where they appear

program (102)
    on left: 1
gComplexProposition (103)
    on left: 2 3, on right: 1
complexProposition (104)
    on left: 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
    24 25 26, on right: 2 4 5 6 7 8 9 10 11 12 13 19 20 21 22 25 26
    27
poptional_projection (105)
    on left: 27 28, on right: 22 27
statement (106)
    on left: 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46
    47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63,
    on right: 1 29 30 31 32 33 52 53 54 56 58 59 60 61 62 63 64 65
    221 222 223 224 232 233
leftpart_4prj (107)
    on left: 64 65 66, on right: 60 66 68 70
optional_leftpart_4prj (108)
    on left: 67 68, on right: 66 68
optional_projection (109)
    on left: 69 70 71, on right: 60 70
struct_define_statement (110)
    on left: 72, on right: 44
option_struct_declaration (111)
    on left: 73 74, on right: 72 74
struct_identifier (112)
    on left: 75 76, on right: 72
declaration (113)
    on left: 77 78 79 80 81 82 83, on right: 35 38 73 74 226
option_declaration (114)
    on left: 84 85 86 87 88 89 90 91 92 93, on right: 77 78 79 80 81
    82 92 94
inner_option_declaration (115)
    on left: 94 95 96, on right: 84 85 86 87 88 89 90 91 93
init_list (116)
    on left: 97, on right: 87 88 90 99
init_exp (117)
    on left: 98 99, on right: 97 100
option_init_exp (118)
    on left: 100 101, on right: 98 99
ass_statement (119)
    on left: 102, on right: 39 225 230
assign_operator (120)
    on left: 103 104, on right: 102
exp (121)
    on left: 105, on right: 37 59 85 90 91 93 102 152 155 156 173 207
    213 215 232 235 236
bool_exp (122)
    on left: 106 107, on right: 55 56 86 98 105 107 144 228
logic_and_exp (123)
    on left: 108 109, on right: 106 107 109
bit_or_exp (124)
    on left: 110 111, on right: 108 109 111
bit_xor_exp (125)
    on left: 112 113, on right: 110 111 113
bit_and_exp (126)
    on left: 114 115, on right: 112 113 115
equlity_exp (127)
    on left: 116 117 118, on right: 114 115 117 118
relation_exp (128)
    on left: 119 120 121 122 123, on right: 116 117 118 120 121 122
    123
ari_exp (129)
    on left: 124 125 126, on right: 17 24 57 65 66 119 120 121 122
    123 125 126 223
add_exp (130)
    on left: 127 128 129, on right: 124 125 126 128 129
mul_exp (131)
    on left: 130 131 132 133, on right: 127 128 129 131 132 133
unary_exp (132)
    on left: 134 135 136 137 138 139 140 141 142 143 144 145 146,
    on right: 83 102 130 131 132 133 135 136 137 138 139 145 146 203
    204
basic_exp (133)
    on left: 147 148 149 150 151 152, on right: 134 148 149 150 151
    152 207 208
primary_exp (134)
    on left: 153 154 155 156, on right: 147
const_exp (135)
    on left: 157 158 159 160 161 162 163, on right: 153
identifier (136)
    on left: 164 165, on right: 61 84 85 86 87 88 89 90 91 93 148 149
    154 165 206
type_cast (137)
    on left: 166 167 168 169 170, on right: 145
pointer (138)
    on left: 171 172, on right: 141 143 167 169 170 172
option_exp (139)
    on left: 173 174, on right: 59 85 90 91 93 152 173 207 213 235
    236
basic_type (140)
    on left: 175 176 177 178 179 180 181 182 183 184 185 186 187 188
    189 190 191 192 193 194 195 196, on right: 77 140 141 166 167 199
windows_type (141)
    on left: 197 198, on right: 196
func_formal_par (142)
    on left: 199 200 201 202 203 204 205, on right: 36 62 83 170 203
    204 211
option_formal_par (143)
    on left: 206 207 208 209 210, on right: 199 200 201 202 209
inner_func_formal_par (144)
    on left: 211 212, on right: 61 199 200 201 202 203 204
func_actual_par (145)
    on left: 213 214, on right: 150
bool_par (146)
    on left: 215 216, on right: 221 222
strliteral (147)
    on left: 217, on right: 89 91 160
intliteral (148)
    on left: 218, on right: 157
charliteral (149)
    on left: 219, on right: 158
floatliteral (150)
    on left: 220, on right: 159
while_statement (151)
    on left: 221, on right: 48
do_while_statement (152)
    on left: 222, on right: 49
for_statement (153)
    on left: 223, on right: 50
extend_for_statement (154)
    on left: 224, on right: 51
for_sta_init (155)
    on left: 225 226 227, on right: 224
for_sta_condition (156)
    on left: 228 229, on right: 224
for_sta_control (157)
    on left: 230 231, on right: 224
if_statement (158)
    on left: 232, on right: 47
option_else_statement (159)
    on left: 233 234, on right: 232
output_statement (160)
    on left: 235, on right: 46
input_statement (161)
    on left: 236, on right: 45


state 0

    PBEGIN	shift, and go to state 1

    $default	reduce using rule 3 (gComplexProposition)

    program	go to state 529
    gComplexProposition	go to state 2



state 1

    gComplexProposition  ->  PBEGIN . complexProposition PEND   (rule 2)

    EMPTY	shift, and go to state 3
    DEFINE	shift, and go to state 4
    MY_TRUE	shift, and go to state 5
    MY_FALSE	shift, and go to state 6
    SKIP	shift, and go to state 7
    OPEN_PAR	shift, and go to state 8
    OPEN_BPAR	shift, and go to state 9
    NEXT	shift, and go to state 10
    NEGATION	shift, and go to state 11
    LENGTH	shift, and go to state 12
    FINAL	shift, and go to state 13
    KEEP	shift, and go to state 14
    ALWAYS	shift, and go to state 15
    HALT	shift, and go to state 16
    W_NEXT	shift, and go to state 17
    SOMETIMES	shift, and go to state 18
    ID  	shift, and go to state 19

    complexProposition	go to state 20



state 2

    program  ->  gComplexProposition . statement   (rule 1)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 76
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 3

    complexProposition  ->  EMPTY .   (rule 18)

    $default	reduce using rule 18 (complexProposition)



state 4

    complexProposition  ->  DEFINE . ID COLON ari_exp   (rule 24)

    ID  	shift, and go to state 111



state 5

    complexProposition  ->  MY_TRUE .   (rule 15)

    $default	reduce using rule 15 (complexProposition)



state 6

    complexProposition  ->  MY_FALSE .   (rule 16)

    $default	reduce using rule 16 (complexProposition)



state 7

    complexProposition  ->  SKIP .   (rule 14)

    $default	reduce using rule 14 (complexProposition)



state 8

    complexProposition  ->  OPEN_PAR . complexProposition CLOSE_PAR   (rule 26)

    EMPTY	shift, and go to state 3
    DEFINE	shift, and go to state 4
    MY_TRUE	shift, and go to state 5
    MY_FALSE	shift, and go to state 6
    SKIP	shift, and go to state 7
    OPEN_PAR	shift, and go to state 8
    OPEN_BPAR	shift, and go to state 9
    NEXT	shift, and go to state 10
    NEGATION	shift, and go to state 11
    LENGTH	shift, and go to state 12
    FINAL	shift, and go to state 13
    KEEP	shift, and go to state 14
    ALWAYS	shift, and go to state 15
    HALT	shift, and go to state 16
    W_NEXT	shift, and go to state 17
    SOMETIMES	shift, and go to state 18
    ID  	shift, and go to state 19

    complexProposition	go to state 112



state 9

    complexProposition  ->  OPEN_BPAR . complexProposition poptional_projection CLOSE_BPAR PROJECTION OPEN_BPAR complexProposition CLOSE_BPAR   (rule 22)

    EMPTY	shift, and go to state 3
    DEFINE	shift, and go to state 4
    MY_TRUE	shift, and go to state 5
    MY_FALSE	shift, and go to state 6
    SKIP	shift, and go to state 7
    OPEN_PAR	shift, and go to state 8
    OPEN_BPAR	shift, and go to state 9
    NEXT	shift, and go to state 10
    NEGATION	shift, and go to state 11
    LENGTH	shift, and go to state 12
    FINAL	shift, and go to state 13
    KEEP	shift, and go to state 14
    ALWAYS	shift, and go to state 15
    HALT	shift, and go to state 16
    W_NEXT	shift, and go to state 17
    SOMETIMES	shift, and go to state 18
    ID  	shift, and go to state 19

    complexProposition	go to state 113



state 10

    complexProposition  ->  NEXT . complexProposition   (rule 13)

    EMPTY	shift, and go to state 3
    DEFINE	shift, and go to state 4
    MY_TRUE	shift, and go to state 5
    MY_FALSE	shift, and go to state 6
    SKIP	shift, and go to state 7
    OPEN_PAR	shift, and go to state 8
    OPEN_BPAR	shift, and go to state 9
    NEXT	shift, and go to state 10
    NEGATION	shift, and go to state 11
    LENGTH	shift, and go to state 12
    FINAL	shift, and go to state 13
    KEEP	shift, and go to state 14
    ALWAYS	shift, and go to state 15
    HALT	shift, and go to state 16
    W_NEXT	shift, and go to state 17
    SOMETIMES	shift, and go to state 18
    ID  	shift, and go to state 19

    complexProposition	go to state 114



state 11

    complexProposition  ->  NEGATION . complexProposition   (rule 21)

    EMPTY	shift, and go to state 3
    DEFINE	shift, and go to state 4
    MY_TRUE	shift, and go to state 5
    MY_FALSE	shift, and go to state 6
    SKIP	shift, and go to state 7
    OPEN_PAR	shift, and go to state 8
    OPEN_BPAR	shift, and go to state 9
    NEXT	shift, and go to state 10
    NEGATION	shift, and go to state 11
    LENGTH	shift, and go to state 12
    FINAL	shift, and go to state 13
    KEEP	shift, and go to state 14
    ALWAYS	shift, and go to state 15
    HALT	shift, and go to state 16
    W_NEXT	shift, and go to state 17
    SOMETIMES	shift, and go to state 18
    ID  	shift, and go to state 19

    complexProposition	go to state 115



state 12

    complexProposition  ->  LENGTH . ari_exp   (rule 17)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    ari_exp	go to state 120
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 13

    complexProposition  ->  FINAL . complexProposition   (rule 20)

    EMPTY	shift, and go to state 3
    DEFINE	shift, and go to state 4
    MY_TRUE	shift, and go to state 5
    MY_FALSE	shift, and go to state 6
    SKIP	shift, and go to state 7
    OPEN_PAR	shift, and go to state 8
    OPEN_BPAR	shift, and go to state 9
    NEXT	shift, and go to state 10
    NEGATION	shift, and go to state 11
    LENGTH	shift, and go to state 12
    FINAL	shift, and go to state 13
    KEEP	shift, and go to state 14
    ALWAYS	shift, and go to state 15
    HALT	shift, and go to state 16
    W_NEXT	shift, and go to state 17
    SOMETIMES	shift, and go to state 18
    ID  	shift, and go to state 19

    complexProposition	go to state 122



state 14

    complexProposition  ->  KEEP . complexProposition   (rule 10)

    EMPTY	shift, and go to state 3
    DEFINE	shift, and go to state 4
    MY_TRUE	shift, and go to state 5
    MY_FALSE	shift, and go to state 6
    SKIP	shift, and go to state 7
    OPEN_PAR	shift, and go to state 8
    OPEN_BPAR	shift, and go to state 9
    NEXT	shift, and go to state 10
    NEGATION	shift, and go to state 11
    LENGTH	shift, and go to state 12
    FINAL	shift, and go to state 13
    KEEP	shift, and go to state 14
    ALWAYS	shift, and go to state 15
    HALT	shift, and go to state 16
    W_NEXT	shift, and go to state 17
    SOMETIMES	shift, and go to state 18
    ID  	shift, and go to state 19

    complexProposition	go to state 123



state 15

    complexProposition  ->  ALWAYS . complexProposition   (rule 9)

    EMPTY	shift, and go to state 3
    DEFINE	shift, and go to state 4
    MY_TRUE	shift, and go to state 5
    MY_FALSE	shift, and go to state 6
    SKIP	shift, and go to state 7
    OPEN_PAR	shift, and go to state 8
    OPEN_BPAR	shift, and go to state 9
    NEXT	shift, and go to state 10
    NEGATION	shift, and go to state 11
    LENGTH	shift, and go to state 12
    FINAL	shift, and go to state 13
    KEEP	shift, and go to state 14
    ALWAYS	shift, and go to state 15
    HALT	shift, and go to state 16
    W_NEXT	shift, and go to state 17
    SOMETIMES	shift, and go to state 18
    ID  	shift, and go to state 19

    complexProposition	go to state 124



state 16

    complexProposition  ->  HALT . complexProposition   (rule 19)

    EMPTY	shift, and go to state 3
    DEFINE	shift, and go to state 4
    MY_TRUE	shift, and go to state 5
    MY_FALSE	shift, and go to state 6
    SKIP	shift, and go to state 7
    OPEN_PAR	shift, and go to state 8
    OPEN_BPAR	shift, and go to state 9
    NEXT	shift, and go to state 10
    NEGATION	shift, and go to state 11
    LENGTH	shift, and go to state 12
    FINAL	shift, and go to state 13
    KEEP	shift, and go to state 14
    ALWAYS	shift, and go to state 15
    HALT	shift, and go to state 16
    W_NEXT	shift, and go to state 17
    SOMETIMES	shift, and go to state 18
    ID  	shift, and go to state 19

    complexProposition	go to state 125



state 17

    complexProposition  ->  W_NEXT . complexProposition   (rule 12)

    EMPTY	shift, and go to state 3
    DEFINE	shift, and go to state 4
    MY_TRUE	shift, and go to state 5
    MY_FALSE	shift, and go to state 6
    SKIP	shift, and go to state 7
    OPEN_PAR	shift, and go to state 8
    OPEN_BPAR	shift, and go to state 9
    NEXT	shift, and go to state 10
    NEGATION	shift, and go to state 11
    LENGTH	shift, and go to state 12
    FINAL	shift, and go to state 13
    KEEP	shift, and go to state 14
    ALWAYS	shift, and go to state 15
    HALT	shift, and go to state 16
    W_NEXT	shift, and go to state 17
    SOMETIMES	shift, and go to state 18
    ID  	shift, and go to state 19

    complexProposition	go to state 126



state 18

    complexProposition  ->  SOMETIMES . complexProposition   (rule 11)

    EMPTY	shift, and go to state 3
    DEFINE	shift, and go to state 4
    MY_TRUE	shift, and go to state 5
    MY_FALSE	shift, and go to state 6
    SKIP	shift, and go to state 7
    OPEN_PAR	shift, and go to state 8
    OPEN_BPAR	shift, and go to state 9
    NEXT	shift, and go to state 10
    NEGATION	shift, and go to state 11
    LENGTH	shift, and go to state 12
    FINAL	shift, and go to state 13
    KEEP	shift, and go to state 14
    ALWAYS	shift, and go to state 15
    HALT	shift, and go to state 16
    W_NEXT	shift, and go to state 17
    SOMETIMES	shift, and go to state 18
    ID  	shift, and go to state 19

    complexProposition	go to state 127



state 19

    complexProposition  ->  ID .   (rule 23)

    $default	reduce using rule 23 (complexProposition)



state 20

    gComplexProposition  ->  PBEGIN complexProposition . PEND   (rule 2)
    complexProposition  ->  complexProposition . AND complexProposition   (rule 4)
    complexProposition  ->  complexProposition . OR complexProposition   (rule 5)
    complexProposition  ->  complexProposition . IFF complexProposition   (rule 6)
    complexProposition  ->  complexProposition . PROPIMPLY complexProposition   (rule 7)
    complexProposition  ->  complexProposition . CHOP complexProposition   (rule 8)
    complexProposition  ->  complexProposition . CHOPSTAR   (rule 25)

    PEND	shift, and go to state 128
    CHOP	shift, and go to state 129
    OR  	shift, and go to state 130
    AND 	shift, and go to state 131
    IFF 	shift, and go to state 132
    PROPIMPLY	shift, and go to state 133
    CHOPSTAR	shift, and go to state 134



state 21

    statement  ->  INCLUDE . STRLITERAL   (rule 34)

    STRLITERAL	shift, and go to state 135



state 22

    primary_exp  ->  IF . exp THEN exp ELSE exp   (rule 156)
    if_statement  ->  IF . exp THEN OPEN_BPAR statement CLOSE_BPAR option_else_statement   (rule 232)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    exp 	go to state 136
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 23

    statement  ->  EMPTY .   (rule 41)

    $default	reduce using rule 41 (statement)



state 24

    statement  ->  AWAIT . OPEN_PAR bool_exp CLOSE_PAR   (rule 55)

    OPEN_PAR	shift, and go to state 137



state 25

    const_exp  ->  POINTERNULL .   (rule 163)

    $default	reduce using rule 163 (const_exp)



state 26

    struct_identifier  ->  STRUCT . ID   (rule 75)
    declaration  ->  STRUCT . ID option_declaration   (rule 79)
    declaration  ->  STRUCT . STRUCT_TYPE option_declaration   (rule 81)

    ID  	shift, and go to state 138
    STRUCT_TYPE	shift, and go to state 139



state 27

    struct_identifier  ->  UNION . ID   (rule 76)
    declaration  ->  UNION . ID option_declaration   (rule 80)
    declaration  ->  UNION . STRUCT_TYPE option_declaration   (rule 82)

    ID  	shift, and go to state 140
    STRUCT_TYPE	shift, and go to state 141



state 28

    basic_type  ->  FILEDEC .   (rule 195)

    $default	reduce using rule 195 (basic_type)



state 29

    const_exp  ->  MY_TRUE .   (rule 161)

    $default	reduce using rule 161 (const_exp)



state 30

    const_exp  ->  MY_FALSE .   (rule 162)

    $default	reduce using rule 162 (const_exp)



state 31

    statement  ->  EXIST . identifier inner_func_formal_par COLON OPEN_BPAR statement CLOSE_BPAR   (rule 61)

    OPEN_PAR	shift, and go to state 142
    ID  	shift, and go to state 70

    identifier	go to state 143



state 32

    statement  ->  FRAME . OPEN_PAR exp option_exp CLOSE_PAR AND OPEN_PAR statement CLOSE_PAR   (rule 59)

    OPEN_PAR	shift, and go to state 144



state 33

    for_statement  ->  FOR . ari_exp TIMES DO OPEN_BPAR statement CLOSE_BPAR   (rule 223)
    extend_for_statement  ->  FOR . OPEN_PAR for_sta_init COMMA for_sta_condition COMMA for_sta_control CLOSE_PAR OPEN_BPAR statement CLOSE_BPAR   (rule 224)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 145
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    ari_exp	go to state 146
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 34

    while_statement  ->  WHILE . bool_par OPEN_BPAR statement CLOSE_BPAR   (rule 221)

    error	shift, and go to state 147
    OPEN_PAR	shift, and go to state 148

    bool_par	go to state 149



state 35

    do_while_statement  ->  DO . OPEN_BPAR statement CLOSE_BPAR WHILE bool_par   (rule 222)

    OPEN_BPAR	shift, and go to state 150



state 36

    statement  ->  TRUE .   (rule 42)

    $default	reduce using rule 42 (statement)



state 37

    statement  ->  FALSE .   (rule 43)

    $default	reduce using rule 43 (statement)



state 38

    statement  ->  REPEAT . OPEN_BPAR statement CLOSE_BPAR UNTIL OPEN_PAR bool_exp CLOSE_PAR   (rule 56)

    OPEN_BPAR	shift, and go to state 151



state 39

    output_statement  ->  DISPLAY . OPEN_PAR exp option_exp CLOSE_PAR   (rule 235)

    OPEN_PAR	shift, and go to state 152



state 40

    statement  ->  SKIP .   (rule 40)

    $default	reduce using rule 40 (statement)



state 41

    declaration  ->  VOID . OPEN_PAR unary_exp CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR   (rule 83)
    basic_type  ->  VOID .   (rule 175)

    OPEN_PAR	shift, and go to state 153

    OPEN_PAR	[reduce using rule 175 (basic_type)]
    $default	reduce using rule 175 (basic_type)



state 42

    basic_type  ->  BOOL .   (rule 176)

    $default	reduce using rule 176 (basic_type)



state 43

    basic_type  ->  CHAR .   (rule 177)

    $default	reduce using rule 177 (basic_type)



state 44

    basic_type  ->  SHORT .   (rule 180)

    $default	reduce using rule 180 (basic_type)



state 45

    basic_type  ->  INT .   (rule 183)

    $default	reduce using rule 183 (basic_type)



state 46

    basic_type  ->  LONG .   (rule 186)
    basic_type  ->  LONG . LONG   (rule 189)

    LONG	shift, and go to state 154

    $default	reduce using rule 186 (basic_type)



state 47

    basic_type  ->  STR .   (rule 194)

    $default	reduce using rule 194 (basic_type)



state 48

    basic_type  ->  FLOAT .   (rule 192)

    $default	reduce using rule 192 (basic_type)



state 49

    basic_type  ->  DOUBLE .   (rule 193)

    $default	reduce using rule 193 (basic_type)



state 50

    windows_type  ->  CRITICAL_SECTION .   (rule 197)

    $default	reduce using rule 197 (windows_type)



state 51

    windows_type  ->  TIMECAPS .   (rule 198)

    $default	reduce using rule 198 (windows_type)



state 52

    statement  ->  OPEN_PAR . statement CLOSE_PAR   (rule 63)
    primary_exp  ->  OPEN_PAR . exp CLOSE_PAR   (rule 155)
    identifier  ->  OPEN_PAR . identifier CLOSE_PAR   (rule 165)
    type_cast  ->  OPEN_PAR . basic_type CLOSE_PAR   (rule 166)
    type_cast  ->  OPEN_PAR . basic_type pointer CLOSE_PAR   (rule 167)
    type_cast  ->  OPEN_PAR . STRUCT_TYPE CLOSE_PAR   (rule 168)
    type_cast  ->  OPEN_PAR . STRUCT_TYPE pointer CLOSE_PAR   (rule 169)
    type_cast  ->  OPEN_PAR . VOID OPEN_PAR pointer CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR CLOSE_PAR   (rule 170)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 155
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 156
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 157
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 158
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 159
    type_cast	go to state 97
    basic_type	go to state 160
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 53

    statement  ->  OPEN_BPAR . leftpart_4prj optional_projection CLOSE_BPAR PROJECTION OPEN_BPAR statement CLOSE_BPAR   (rule 60)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 161
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 162
    leftpart_4prj	go to state 163
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 54

    statement  ->  FUNCTION . ID OPEN_PAR func_formal_par CLOSE_PAR OPEN_BPAR statement CLOSE_BPAR   (rule 62)

    ID  	shift, and go to state 164



state 55

    basic_type  ->  UNSIGNED . CHAR   (rule 179)
    basic_type  ->  UNSIGNED . SHORT   (rule 182)
    basic_type  ->  UNSIGNED . INT   (rule 185)
    basic_type  ->  UNSIGNED . LONG   (rule 188)
    basic_type  ->  UNSIGNED . LONG LONG   (rule 191)

    CHAR	shift, and go to state 165
    SHORT	shift, and go to state 166
    INT 	shift, and go to state 167
    LONG	shift, and go to state 168



state 56

    basic_type  ->  SIGNED . CHAR   (rule 178)
    basic_type  ->  SIGNED . SHORT   (rule 181)
    basic_type  ->  SIGNED . INT   (rule 184)
    basic_type  ->  SIGNED . LONG   (rule 187)
    basic_type  ->  SIGNED . LONG LONG   (rule 190)

    CHAR	shift, and go to state 169
    SHORT	shift, and go to state 170
    INT 	shift, and go to state 171
    LONG	shift, and go to state 172



state 57

    unary_exp  ->  SIZEOF . OPEN_PAR basic_type CLOSE_PAR   (rule 140)
    unary_exp  ->  SIZEOF . OPEN_PAR basic_type pointer CLOSE_PAR   (rule 141)
    unary_exp  ->  SIZEOF . OPEN_PAR STRUCT_TYPE CLOSE_PAR   (rule 142)
    unary_exp  ->  SIZEOF . OPEN_PAR STRUCT_TYPE pointer CLOSE_PAR   (rule 143)
    unary_exp  ->  SIZEOF . OPEN_PAR bool_exp CLOSE_PAR   (rule 144)

    OPEN_PAR	shift, and go to state 173



state 58

    statement  ->  EXTERN . declaration   (rule 35)
    statement  ->  EXTERN . FUNCTION ID OPEN_PAR func_formal_par CLOSE_PAR   (rule 36)
    basic_exp  ->  EXTERN . basic_exp   (rule 151)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 174
    UNION	shift, and go to state 175
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 176
    FUNCTION	shift, and go to state 177
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    EXTERN	shift, and go to state 118
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    declaration	go to state 178
    basic_exp	go to state 179
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 59

    unary_exp  ->  ADDRESS . unary_exp   (rule 135)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    unary_exp	go to state 180
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 60

    unary_exp  ->  SUB . unary_exp   (rule 137)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    unary_exp	go to state 181
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 61

    unary_exp  ->  MUL . unary_exp   (rule 136)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    unary_exp	go to state 182
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 62

    unary_exp  ->  BNE . unary_exp   (rule 139)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    unary_exp	go to state 183
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 63

    statement  ->  NEXT . OPEN_PAR statement CLOSE_PAR   (rule 52)
    unary_exp  ->  NEXT . unary_exp   (rule 146)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 184
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    unary_exp	go to state 185
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 64

    unary_exp  ->  NEGATION . unary_exp   (rule 138)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    unary_exp	go to state 186
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 65

    statement  ->  LENGTH . OPEN_PAR ari_exp CLOSE_PAR   (rule 57)

    OPEN_PAR	shift, and go to state 187



state 66

    input_statement  ->  REQUEST . OPEN_PAR exp option_exp CLOSE_PAR   (rule 236)

    OPEN_PAR	shift, and go to state 188



state 67

    statement  ->  FINAL . OPEN_PAR statement CLOSE_PAR   (rule 58)

    OPEN_PAR	shift, and go to state 189



state 68

    statement  ->  KEEP . OPEN_PAR statement CLOSE_PAR   (rule 53)

    OPEN_PAR	shift, and go to state 190



state 69

    statement  ->  ALWAYS . OPEN_PAR statement CLOSE_PAR   (rule 54)

    OPEN_PAR	shift, and go to state 191



state 70

    identifier  ->  ID .   (rule 164)

    $default	reduce using rule 164 (identifier)



state 71

    strliteral  ->  STRLITERAL .   (rule 217)

    $default	reduce using rule 217 (strliteral)



state 72

    declaration  ->  STRUCT_TYPE . option_declaration   (rule 78)

    OPEN_PAR	shift, and go to state 192
    MUL 	shift, and go to state 193
    ID  	shift, and go to state 70

    option_declaration	go to state 194
    identifier	go to state 195



state 73

    intliteral  ->  INTLITERAL .   (rule 218)

    $default	reduce using rule 218 (intliteral)



state 74

    floatliteral  ->  FLOATLITERAL .   (rule 220)

    $default	reduce using rule 220 (floatliteral)



state 75

    charliteral  ->  CHARLITERAL .   (rule 219)

    $default	reduce using rule 219 (charliteral)



state 76

    program  ->  gComplexProposition statement .   (rule 1)
    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)

    ARRAY	shift, and go to state 196
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200

    $default	reduce using rule 1 (program)



state 77

    statement  ->  struct_define_statement .   (rule 44)

    $default	reduce using rule 44 (statement)



state 78

    struct_define_statement  ->  struct_identifier . OPEN_BPAR option_struct_declaration CLOSE_BPAR   (rule 72)

    OPEN_BPAR	shift, and go to state 201



state 79

    statement  ->  declaration .   (rule 38)

    $default	reduce using rule 38 (statement)



state 80

    statement  ->  ass_statement .   (rule 39)

    $default	reduce using rule 39 (statement)



state 81

    statement  ->  exp .   (rule 37)

    $default	reduce using rule 37 (statement)



state 82

    exp  ->  bool_exp .   (rule 105)
    bool_exp  ->  bool_exp . BOOL_OR logic_and_exp   (rule 107)

    BOOL_OR	shift, and go to state 202

    BOOL_OR	[reduce using rule 105 (exp)]
    $default	reduce using rule 105 (exp)



state 83

    bool_exp  ->  logic_and_exp .   (rule 106)
    logic_and_exp  ->  logic_and_exp . BOOL_AND bit_or_exp   (rule 109)

    BOOL_AND	shift, and go to state 203

    BOOL_AND	[reduce using rule 106 (bool_exp)]
    $default	reduce using rule 106 (bool_exp)



state 84

    logic_and_exp  ->  bit_or_exp .   (rule 108)
    bit_or_exp  ->  bit_or_exp . INTER_OR bit_xor_exp   (rule 111)

    INTER_OR	shift, and go to state 204

    INTER_OR	[reduce using rule 108 (logic_and_exp)]
    $default	reduce using rule 108 (logic_and_exp)



state 85

    bit_or_exp  ->  bit_xor_exp .   (rule 110)
    bit_xor_exp  ->  bit_xor_exp . XOR bit_and_exp   (rule 113)

    XOR 	shift, and go to state 205

    XOR 	[reduce using rule 110 (bit_or_exp)]
    $default	reduce using rule 110 (bit_or_exp)



state 86

    bit_xor_exp  ->  bit_and_exp .   (rule 112)
    bit_and_exp  ->  bit_and_exp . ADDRESS equlity_exp   (rule 115)

    ADDRESS	shift, and go to state 206

    ADDRESS	[reduce using rule 112 (bit_xor_exp)]
    $default	reduce using rule 112 (bit_xor_exp)



state 87

    bit_and_exp  ->  equlity_exp .   (rule 114)
    equlity_exp  ->  equlity_exp . EQ relation_exp   (rule 117)
    equlity_exp  ->  equlity_exp . NE relation_exp   (rule 118)

    NE  	shift, and go to state 207
    EQ  	shift, and go to state 208

    NE  	[reduce using rule 114 (bit_and_exp)]
    EQ  	[reduce using rule 114 (bit_and_exp)]
    $default	reduce using rule 114 (bit_and_exp)



state 88

    equlity_exp  ->  relation_exp .   (rule 116)
    relation_exp  ->  relation_exp . GT ari_exp   (rule 120)
    relation_exp  ->  relation_exp . GE ari_exp   (rule 121)
    relation_exp  ->  relation_exp . LT ari_exp   (rule 122)
    relation_exp  ->  relation_exp . LE ari_exp   (rule 123)

    GE  	shift, and go to state 209
    LE  	shift, and go to state 210
    GT  	shift, and go to state 211
    LT  	shift, and go to state 212

    GE  	[reduce using rule 116 (equlity_exp)]
    LE  	[reduce using rule 116 (equlity_exp)]
    GT  	[reduce using rule 116 (equlity_exp)]
    LT  	[reduce using rule 116 (equlity_exp)]
    $default	reduce using rule 116 (equlity_exp)



state 89

    relation_exp  ->  ari_exp .   (rule 119)
    ari_exp  ->  ari_exp . LST add_exp   (rule 125)
    ari_exp  ->  ari_exp . RST add_exp   (rule 126)

    LST 	shift, and go to state 213
    RST 	shift, and go to state 214

    LST 	[reduce using rule 119 (relation_exp)]
    RST 	[reduce using rule 119 (relation_exp)]
    $default	reduce using rule 119 (relation_exp)



state 90

    ari_exp  ->  add_exp .   (rule 124)
    add_exp  ->  add_exp . ADD mul_exp   (rule 128)
    add_exp  ->  add_exp . SUB mul_exp   (rule 129)

    ADD 	shift, and go to state 215
    SUB 	shift, and go to state 216

    ADD 	[reduce using rule 124 (ari_exp)]
    SUB 	[reduce using rule 124 (ari_exp)]
    $default	reduce using rule 124 (ari_exp)



state 91

    add_exp  ->  mul_exp .   (rule 127)
    mul_exp  ->  mul_exp . MUL unary_exp   (rule 131)
    mul_exp  ->  mul_exp . DIV unary_exp   (rule 132)
    mul_exp  ->  mul_exp . MOD unary_exp   (rule 133)

    MUL 	shift, and go to state 217
    DIV 	shift, and go to state 218
    MOD 	shift, and go to state 219

    MUL 	[reduce using rule 127 (add_exp)]
    DIV 	[reduce using rule 127 (add_exp)]
    MOD 	[reduce using rule 127 (add_exp)]
    $default	reduce using rule 127 (add_exp)



state 92

    ass_statement  ->  unary_exp . assign_operator exp   (rule 102)
    mul_exp  ->  unary_exp .   (rule 130)

    ASS_P	shift, and go to state 220
    ASS_N	shift, and go to state 221

    $default	reduce using rule 130 (mul_exp)

    assign_operator	go to state 222



state 93

    unary_exp  ->  basic_exp .   (rule 134)
    basic_exp  ->  basic_exp . DOT identifier   (rule 148)
    basic_exp  ->  basic_exp . IMPLY identifier   (rule 149)
    basic_exp  ->  basic_exp . OPEN_PAR func_actual_par CLOSE_PAR   (rule 150)
    basic_exp  ->  basic_exp . OPEN_MPAR exp option_exp CLOSE_MPAR   (rule 152)

    DOT 	shift, and go to state 223
    OPEN_PAR	shift, and go to state 224
    OPEN_MPAR	shift, and go to state 225
    IMPLY	shift, and go to state 226

    DOT 	[reduce using rule 134 (unary_exp)]
    OPEN_PAR	[reduce using rule 134 (unary_exp)]
    OPEN_MPAR	[reduce using rule 134 (unary_exp)]
    IMPLY	[reduce using rule 134 (unary_exp)]
    $default	reduce using rule 134 (unary_exp)



state 94

    basic_exp  ->  primary_exp .   (rule 147)

    $default	reduce using rule 147 (basic_exp)



state 95

    primary_exp  ->  const_exp .   (rule 153)

    $default	reduce using rule 153 (primary_exp)



state 96

    primary_exp  ->  identifier .   (rule 154)

    $default	reduce using rule 154 (primary_exp)



state 97

    unary_exp  ->  type_cast . unary_exp   (rule 145)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    unary_exp	go to state 227
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 98

    declaration  ->  basic_type . option_declaration   (rule 77)

    OPEN_PAR	shift, and go to state 192
    MUL 	shift, and go to state 193
    ID  	shift, and go to state 70

    option_declaration	go to state 228
    identifier	go to state 195



state 99

    basic_type  ->  windows_type .   (rule 196)

    $default	reduce using rule 196 (basic_type)



state 100

    const_exp  ->  strliteral .   (rule 160)

    $default	reduce using rule 160 (const_exp)



state 101

    const_exp  ->  intliteral .   (rule 157)

    $default	reduce using rule 157 (const_exp)



state 102

    const_exp  ->  charliteral .   (rule 158)

    $default	reduce using rule 158 (const_exp)



state 103

    const_exp  ->  floatliteral .   (rule 159)

    $default	reduce using rule 159 (const_exp)



state 104

    statement  ->  while_statement .   (rule 48)

    $default	reduce using rule 48 (statement)



state 105

    statement  ->  do_while_statement .   (rule 49)

    $default	reduce using rule 49 (statement)



state 106

    statement  ->  for_statement .   (rule 50)

    $default	reduce using rule 50 (statement)



state 107

    statement  ->  extend_for_statement .   (rule 51)

    $default	reduce using rule 51 (statement)



state 108

    statement  ->  if_statement .   (rule 47)

    $default	reduce using rule 47 (statement)



state 109

    statement  ->  output_statement .   (rule 46)

    $default	reduce using rule 46 (statement)



state 110

    statement  ->  input_statement .   (rule 45)

    $default	reduce using rule 45 (statement)



state 111

    complexProposition  ->  DEFINE ID . COLON ari_exp   (rule 24)

    COLON	shift, and go to state 229



state 112

    complexProposition  ->  complexProposition . AND complexProposition   (rule 4)
    complexProposition  ->  complexProposition . OR complexProposition   (rule 5)
    complexProposition  ->  complexProposition . IFF complexProposition   (rule 6)
    complexProposition  ->  complexProposition . PROPIMPLY complexProposition   (rule 7)
    complexProposition  ->  complexProposition . CHOP complexProposition   (rule 8)
    complexProposition  ->  complexProposition . CHOPSTAR   (rule 25)
    complexProposition  ->  OPEN_PAR complexProposition . CLOSE_PAR   (rule 26)

    CLOSE_PAR	shift, and go to state 230
    CHOP	shift, and go to state 129
    OR  	shift, and go to state 130
    AND 	shift, and go to state 131
    IFF 	shift, and go to state 132
    PROPIMPLY	shift, and go to state 133
    CHOPSTAR	shift, and go to state 134



state 113

    complexProposition  ->  complexProposition . AND complexProposition   (rule 4)
    complexProposition  ->  complexProposition . OR complexProposition   (rule 5)
    complexProposition  ->  complexProposition . IFF complexProposition   (rule 6)
    complexProposition  ->  complexProposition . PROPIMPLY complexProposition   (rule 7)
    complexProposition  ->  complexProposition . CHOP complexProposition   (rule 8)
    complexProposition  ->  OPEN_BPAR complexProposition . poptional_projection CLOSE_BPAR PROJECTION OPEN_BPAR complexProposition CLOSE_BPAR   (rule 22)
    complexProposition  ->  complexProposition . CHOPSTAR   (rule 25)

    COMMA	shift, and go to state 231
    CHOP	shift, and go to state 129
    OR  	shift, and go to state 130
    AND 	shift, and go to state 131
    IFF 	shift, and go to state 132
    PROPIMPLY	shift, and go to state 133
    CHOPSTAR	shift, and go to state 134

    $default	reduce using rule 28 (poptional_projection)

    poptional_projection	go to state 232



state 114

    complexProposition  ->  complexProposition . AND complexProposition   (rule 4)
    complexProposition  ->  complexProposition . OR complexProposition   (rule 5)
    complexProposition  ->  complexProposition . IFF complexProposition   (rule 6)
    complexProposition  ->  complexProposition . PROPIMPLY complexProposition   (rule 7)
    complexProposition  ->  complexProposition . CHOP complexProposition   (rule 8)
    complexProposition  ->  NEXT complexProposition .   (rule 13)
    complexProposition  ->  complexProposition . CHOPSTAR   (rule 25)


    CHOPSTAR	error (nonassociative)

    $default	reduce using rule 13 (complexProposition)



state 115

    complexProposition  ->  complexProposition . AND complexProposition   (rule 4)
    complexProposition  ->  complexProposition . OR complexProposition   (rule 5)
    complexProposition  ->  complexProposition . IFF complexProposition   (rule 6)
    complexProposition  ->  complexProposition . PROPIMPLY complexProposition   (rule 7)
    complexProposition  ->  complexProposition . CHOP complexProposition   (rule 8)
    complexProposition  ->  NEGATION complexProposition .   (rule 21)
    complexProposition  ->  complexProposition . CHOPSTAR   (rule 25)


    CHOPSTAR	error (nonassociative)

    $default	reduce using rule 21 (complexProposition)



state 116

    primary_exp  ->  IF . exp THEN exp ELSE exp   (rule 156)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    exp 	go to state 233
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 117

    primary_exp  ->  OPEN_PAR . exp CLOSE_PAR   (rule 155)
    identifier  ->  OPEN_PAR . identifier CLOSE_PAR   (rule 165)
    type_cast  ->  OPEN_PAR . basic_type CLOSE_PAR   (rule 166)
    type_cast  ->  OPEN_PAR . basic_type pointer CLOSE_PAR   (rule 167)
    type_cast  ->  OPEN_PAR . STRUCT_TYPE CLOSE_PAR   (rule 168)
    type_cast  ->  OPEN_PAR . STRUCT_TYPE pointer CLOSE_PAR   (rule 169)
    type_cast  ->  OPEN_PAR . VOID OPEN_PAR pointer CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR CLOSE_PAR   (rule 170)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    VOID	shift, and go to state 234
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 117
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 235
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    exp 	go to state 236
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 159
    type_cast	go to state 97
    basic_type	go to state 237
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 118

    basic_exp  ->  EXTERN . basic_exp   (rule 151)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 176
    EXTERN	shift, and go to state 118
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    basic_exp	go to state 179
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 119

    unary_exp  ->  NEXT . unary_exp   (rule 146)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    unary_exp	go to state 185
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 120

    complexProposition  ->  LENGTH ari_exp .   (rule 17)
    ari_exp  ->  ari_exp . LST add_exp   (rule 125)
    ari_exp  ->  ari_exp . RST add_exp   (rule 126)

    LST 	shift, and go to state 213
    RST 	shift, and go to state 214

    $default	reduce using rule 17 (complexProposition)



state 121

    mul_exp  ->  unary_exp .   (rule 130)

    $default	reduce using rule 130 (mul_exp)



state 122

    complexProposition  ->  complexProposition . AND complexProposition   (rule 4)
    complexProposition  ->  complexProposition . OR complexProposition   (rule 5)
    complexProposition  ->  complexProposition . IFF complexProposition   (rule 6)
    complexProposition  ->  complexProposition . PROPIMPLY complexProposition   (rule 7)
    complexProposition  ->  complexProposition . CHOP complexProposition   (rule 8)
    complexProposition  ->  FINAL complexProposition .   (rule 20)
    complexProposition  ->  complexProposition . CHOPSTAR   (rule 25)


    CHOPSTAR	error (nonassociative)

    $default	reduce using rule 20 (complexProposition)



state 123

    complexProposition  ->  complexProposition . AND complexProposition   (rule 4)
    complexProposition  ->  complexProposition . OR complexProposition   (rule 5)
    complexProposition  ->  complexProposition . IFF complexProposition   (rule 6)
    complexProposition  ->  complexProposition . PROPIMPLY complexProposition   (rule 7)
    complexProposition  ->  complexProposition . CHOP complexProposition   (rule 8)
    complexProposition  ->  KEEP complexProposition .   (rule 10)
    complexProposition  ->  complexProposition . CHOPSTAR   (rule 25)


    CHOPSTAR	error (nonassociative)

    $default	reduce using rule 10 (complexProposition)



state 124

    complexProposition  ->  complexProposition . AND complexProposition   (rule 4)
    complexProposition  ->  complexProposition . OR complexProposition   (rule 5)
    complexProposition  ->  complexProposition . IFF complexProposition   (rule 6)
    complexProposition  ->  complexProposition . PROPIMPLY complexProposition   (rule 7)
    complexProposition  ->  complexProposition . CHOP complexProposition   (rule 8)
    complexProposition  ->  ALWAYS complexProposition .   (rule 9)
    complexProposition  ->  complexProposition . CHOPSTAR   (rule 25)


    CHOPSTAR	error (nonassociative)

    $default	reduce using rule 9 (complexProposition)



state 125

    complexProposition  ->  complexProposition . AND complexProposition   (rule 4)
    complexProposition  ->  complexProposition . OR complexProposition   (rule 5)
    complexProposition  ->  complexProposition . IFF complexProposition   (rule 6)
    complexProposition  ->  complexProposition . PROPIMPLY complexProposition   (rule 7)
    complexProposition  ->  complexProposition . CHOP complexProposition   (rule 8)
    complexProposition  ->  HALT complexProposition .   (rule 19)
    complexProposition  ->  complexProposition . CHOPSTAR   (rule 25)


    CHOPSTAR	error (nonassociative)

    $default	reduce using rule 19 (complexProposition)



state 126

    complexProposition  ->  complexProposition . AND complexProposition   (rule 4)
    complexProposition  ->  complexProposition . OR complexProposition   (rule 5)
    complexProposition  ->  complexProposition . IFF complexProposition   (rule 6)
    complexProposition  ->  complexProposition . PROPIMPLY complexProposition   (rule 7)
    complexProposition  ->  complexProposition . CHOP complexProposition   (rule 8)
    complexProposition  ->  W_NEXT complexProposition .   (rule 12)
    complexProposition  ->  complexProposition . CHOPSTAR   (rule 25)


    CHOPSTAR	error (nonassociative)

    $default	reduce using rule 12 (complexProposition)



state 127

    complexProposition  ->  complexProposition . AND complexProposition   (rule 4)
    complexProposition  ->  complexProposition . OR complexProposition   (rule 5)
    complexProposition  ->  complexProposition . IFF complexProposition   (rule 6)
    complexProposition  ->  complexProposition . PROPIMPLY complexProposition   (rule 7)
    complexProposition  ->  complexProposition . CHOP complexProposition   (rule 8)
    complexProposition  ->  SOMETIMES complexProposition .   (rule 11)
    complexProposition  ->  complexProposition . CHOPSTAR   (rule 25)


    CHOPSTAR	error (nonassociative)

    $default	reduce using rule 11 (complexProposition)



state 128

    gComplexProposition  ->  PBEGIN complexProposition PEND .   (rule 2)

    $default	reduce using rule 2 (gComplexProposition)



state 129

    complexProposition  ->  complexProposition CHOP . complexProposition   (rule 8)

    EMPTY	shift, and go to state 3
    DEFINE	shift, and go to state 4
    MY_TRUE	shift, and go to state 5
    MY_FALSE	shift, and go to state 6
    SKIP	shift, and go to state 7
    OPEN_PAR	shift, and go to state 8
    OPEN_BPAR	shift, and go to state 9
    NEXT	shift, and go to state 10
    NEGATION	shift, and go to state 11
    LENGTH	shift, and go to state 12
    FINAL	shift, and go to state 13
    KEEP	shift, and go to state 14
    ALWAYS	shift, and go to state 15
    HALT	shift, and go to state 16
    W_NEXT	shift, and go to state 17
    SOMETIMES	shift, and go to state 18
    ID  	shift, and go to state 19

    complexProposition	go to state 238



state 130

    complexProposition  ->  complexProposition OR . complexProposition   (rule 5)

    EMPTY	shift, and go to state 3
    DEFINE	shift, and go to state 4
    MY_TRUE	shift, and go to state 5
    MY_FALSE	shift, and go to state 6
    SKIP	shift, and go to state 7
    OPEN_PAR	shift, and go to state 8
    OPEN_BPAR	shift, and go to state 9
    NEXT	shift, and go to state 10
    NEGATION	shift, and go to state 11
    LENGTH	shift, and go to state 12
    FINAL	shift, and go to state 13
    KEEP	shift, and go to state 14
    ALWAYS	shift, and go to state 15
    HALT	shift, and go to state 16
    W_NEXT	shift, and go to state 17
    SOMETIMES	shift, and go to state 18
    ID  	shift, and go to state 19

    complexProposition	go to state 239



state 131

    complexProposition  ->  complexProposition AND . complexProposition   (rule 4)

    EMPTY	shift, and go to state 3
    DEFINE	shift, and go to state 4
    MY_TRUE	shift, and go to state 5
    MY_FALSE	shift, and go to state 6
    SKIP	shift, and go to state 7
    OPEN_PAR	shift, and go to state 8
    OPEN_BPAR	shift, and go to state 9
    NEXT	shift, and go to state 10
    NEGATION	shift, and go to state 11
    LENGTH	shift, and go to state 12
    FINAL	shift, and go to state 13
    KEEP	shift, and go to state 14
    ALWAYS	shift, and go to state 15
    HALT	shift, and go to state 16
    W_NEXT	shift, and go to state 17
    SOMETIMES	shift, and go to state 18
    ID  	shift, and go to state 19

    complexProposition	go to state 240



state 132

    complexProposition  ->  complexProposition IFF . complexProposition   (rule 6)

    EMPTY	shift, and go to state 3
    DEFINE	shift, and go to state 4
    MY_TRUE	shift, and go to state 5
    MY_FALSE	shift, and go to state 6
    SKIP	shift, and go to state 7
    OPEN_PAR	shift, and go to state 8
    OPEN_BPAR	shift, and go to state 9
    NEXT	shift, and go to state 10
    NEGATION	shift, and go to state 11
    LENGTH	shift, and go to state 12
    FINAL	shift, and go to state 13
    KEEP	shift, and go to state 14
    ALWAYS	shift, and go to state 15
    HALT	shift, and go to state 16
    W_NEXT	shift, and go to state 17
    SOMETIMES	shift, and go to state 18
    ID  	shift, and go to state 19

    complexProposition	go to state 241



state 133

    complexProposition  ->  complexProposition PROPIMPLY . complexProposition   (rule 7)

    EMPTY	shift, and go to state 3
    DEFINE	shift, and go to state 4
    MY_TRUE	shift, and go to state 5
    MY_FALSE	shift, and go to state 6
    SKIP	shift, and go to state 7
    OPEN_PAR	shift, and go to state 8
    OPEN_BPAR	shift, and go to state 9
    NEXT	shift, and go to state 10
    NEGATION	shift, and go to state 11
    LENGTH	shift, and go to state 12
    FINAL	shift, and go to state 13
    KEEP	shift, and go to state 14
    ALWAYS	shift, and go to state 15
    HALT	shift, and go to state 16
    W_NEXT	shift, and go to state 17
    SOMETIMES	shift, and go to state 18
    ID  	shift, and go to state 19

    complexProposition	go to state 242



state 134

    complexProposition  ->  complexProposition CHOPSTAR .   (rule 25)

    $default	reduce using rule 25 (complexProposition)



state 135

    statement  ->  INCLUDE STRLITERAL .   (rule 34)

    $default	reduce using rule 34 (statement)



state 136

    primary_exp  ->  IF exp . THEN exp ELSE exp   (rule 156)
    if_statement  ->  IF exp . THEN OPEN_BPAR statement CLOSE_BPAR option_else_statement   (rule 232)

    THEN	shift, and go to state 243



state 137

    statement  ->  AWAIT OPEN_PAR . bool_exp CLOSE_PAR   (rule 55)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    bool_exp	go to state 244
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 138

    struct_identifier  ->  STRUCT ID .   (rule 75)
    declaration  ->  STRUCT ID . option_declaration   (rule 79)

    OPEN_PAR	shift, and go to state 192
    MUL 	shift, and go to state 193
    ID  	shift, and go to state 70

    $default	reduce using rule 75 (struct_identifier)

    option_declaration	go to state 245
    identifier	go to state 195



state 139

    declaration  ->  STRUCT STRUCT_TYPE . option_declaration   (rule 81)

    OPEN_PAR	shift, and go to state 192
    MUL 	shift, and go to state 193
    ID  	shift, and go to state 70

    option_declaration	go to state 246
    identifier	go to state 195



state 140

    struct_identifier  ->  UNION ID .   (rule 76)
    declaration  ->  UNION ID . option_declaration   (rule 80)

    OPEN_PAR	shift, and go to state 192
    MUL 	shift, and go to state 193
    ID  	shift, and go to state 70

    $default	reduce using rule 76 (struct_identifier)

    option_declaration	go to state 247
    identifier	go to state 195



state 141

    declaration  ->  UNION STRUCT_TYPE . option_declaration   (rule 82)

    OPEN_PAR	shift, and go to state 192
    MUL 	shift, and go to state 193
    ID  	shift, and go to state 70

    option_declaration	go to state 248
    identifier	go to state 195



state 142

    identifier  ->  OPEN_PAR . identifier CLOSE_PAR   (rule 165)

    OPEN_PAR	shift, and go to state 142
    ID  	shift, and go to state 70

    identifier	go to state 249



state 143

    statement  ->  EXIST identifier . inner_func_formal_par COLON OPEN_BPAR statement CLOSE_BPAR   (rule 61)

    COMMA	shift, and go to state 250

    $default	reduce using rule 212 (inner_func_formal_par)

    inner_func_formal_par	go to state 251



state 144

    statement  ->  FRAME OPEN_PAR . exp option_exp CLOSE_PAR AND OPEN_PAR statement CLOSE_PAR   (rule 59)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    exp 	go to state 252
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 145

    primary_exp  ->  OPEN_PAR . exp CLOSE_PAR   (rule 155)
    identifier  ->  OPEN_PAR . identifier CLOSE_PAR   (rule 165)
    type_cast  ->  OPEN_PAR . basic_type CLOSE_PAR   (rule 166)
    type_cast  ->  OPEN_PAR . basic_type pointer CLOSE_PAR   (rule 167)
    type_cast  ->  OPEN_PAR . STRUCT_TYPE CLOSE_PAR   (rule 168)
    type_cast  ->  OPEN_PAR . STRUCT_TYPE pointer CLOSE_PAR   (rule 169)
    type_cast  ->  OPEN_PAR . VOID OPEN_PAR pointer CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR CLOSE_PAR   (rule 170)
    extend_for_statement  ->  FOR OPEN_PAR . for_sta_init COMMA for_sta_condition COMMA for_sta_control CLOSE_PAR OPEN_BPAR statement CLOSE_BPAR   (rule 224)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 174
    UNION	shift, and go to state 175
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    VOID	shift, and go to state 155
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 117
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 156
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    $default	reduce using rule 227 (for_sta_init)

    declaration	go to state 253
    ass_statement	go to state 254
    exp 	go to state 236
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 159
    type_cast	go to state 97
    basic_type	go to state 160
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    for_sta_init	go to state 255



state 146

    ari_exp  ->  ari_exp . LST add_exp   (rule 125)
    ari_exp  ->  ari_exp . RST add_exp   (rule 126)
    for_statement  ->  FOR ari_exp . TIMES DO OPEN_BPAR statement CLOSE_BPAR   (rule 223)

    TIMES	shift, and go to state 256
    LST 	shift, and go to state 213
    RST 	shift, and go to state 214



state 147

    bool_par  ->  error . CLOSE_PAR   (rule 216)

    CLOSE_PAR	shift, and go to state 257



state 148

    bool_par  ->  OPEN_PAR . exp CLOSE_PAR   (rule 215)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    exp 	go to state 258
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 149

    while_statement  ->  WHILE bool_par . OPEN_BPAR statement CLOSE_BPAR   (rule 221)

    OPEN_BPAR	shift, and go to state 259



state 150

    do_while_statement  ->  DO OPEN_BPAR . statement CLOSE_BPAR WHILE bool_par   (rule 222)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 260
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 151

    statement  ->  REPEAT OPEN_BPAR . statement CLOSE_BPAR UNTIL OPEN_PAR bool_exp CLOSE_PAR   (rule 56)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 261
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 152

    output_statement  ->  DISPLAY OPEN_PAR . exp option_exp CLOSE_PAR   (rule 235)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    exp 	go to state 262
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 153

    declaration  ->  VOID OPEN_PAR . unary_exp CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR   (rule 83)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    unary_exp	go to state 263
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 154

    basic_type  ->  LONG LONG .   (rule 189)

    $default	reduce using rule 189 (basic_type)



state 155

    declaration  ->  VOID . OPEN_PAR unary_exp CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR   (rule 83)
    type_cast  ->  OPEN_PAR VOID . OPEN_PAR pointer CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR CLOSE_PAR   (rule 170)
    basic_type  ->  VOID .   (rule 175)

    OPEN_PAR	shift, and go to state 264

    OPEN_PAR	[reduce using rule 175 (basic_type)]
    $default	reduce using rule 175 (basic_type)



state 156

    declaration  ->  STRUCT_TYPE . option_declaration   (rule 78)
    type_cast  ->  OPEN_PAR STRUCT_TYPE . CLOSE_PAR   (rule 168)
    type_cast  ->  OPEN_PAR STRUCT_TYPE . pointer CLOSE_PAR   (rule 169)

    OPEN_PAR	shift, and go to state 192
    CLOSE_PAR	shift, and go to state 265
    MUL 	shift, and go to state 266
    ID  	shift, and go to state 70

    option_declaration	go to state 194
    identifier	go to state 195
    pointer	go to state 267



state 157

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)
    statement  ->  OPEN_PAR statement . CLOSE_PAR   (rule 63)

    ARRAY	shift, and go to state 196
    CLOSE_PAR	shift, and go to state 268
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200



state 158

    statement  ->  exp .   (rule 37)
    primary_exp  ->  OPEN_PAR exp . CLOSE_PAR   (rule 155)

    CLOSE_PAR	shift, and go to state 269

    CLOSE_PAR	[reduce using rule 37 (statement)]
    $default	reduce using rule 37 (statement)



state 159

    primary_exp  ->  identifier .   (rule 154)
    identifier  ->  OPEN_PAR identifier . CLOSE_PAR   (rule 165)

    CLOSE_PAR	shift, and go to state 270

    CLOSE_PAR	[reduce using rule 154 (primary_exp)]
    $default	reduce using rule 154 (primary_exp)



state 160

    declaration  ->  basic_type . option_declaration   (rule 77)
    type_cast  ->  OPEN_PAR basic_type . CLOSE_PAR   (rule 166)
    type_cast  ->  OPEN_PAR basic_type . pointer CLOSE_PAR   (rule 167)

    OPEN_PAR	shift, and go to state 192
    CLOSE_PAR	shift, and go to state 271
    MUL 	shift, and go to state 266
    ID  	shift, and go to state 70

    option_declaration	go to state 228
    identifier	go to state 195
    pointer	go to state 272



state 161

    statement  ->  OPEN_PAR . statement CLOSE_PAR   (rule 63)
    leftpart_4prj  ->  OPEN_PAR . statement CLOSE_PAR XOR ari_exp   (rule 65)
    leftpart_4prj  ->  OPEN_PAR . leftpart_4prj optional_leftpart_4prj CLOSE_PAR XOR ari_exp   (rule 66)
    primary_exp  ->  OPEN_PAR . exp CLOSE_PAR   (rule 155)
    identifier  ->  OPEN_PAR . identifier CLOSE_PAR   (rule 165)
    type_cast  ->  OPEN_PAR . basic_type CLOSE_PAR   (rule 166)
    type_cast  ->  OPEN_PAR . basic_type pointer CLOSE_PAR   (rule 167)
    type_cast  ->  OPEN_PAR . STRUCT_TYPE CLOSE_PAR   (rule 168)
    type_cast  ->  OPEN_PAR . STRUCT_TYPE pointer CLOSE_PAR   (rule 169)
    type_cast  ->  OPEN_PAR . VOID OPEN_PAR pointer CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR CLOSE_PAR   (rule 170)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 155
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 161
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 156
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 273
    leftpart_4prj	go to state 274
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 158
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 159
    type_cast	go to state 97
    basic_type	go to state 160
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 162

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)
    leftpart_4prj  ->  statement .   (rule 64)

    ARRAY	shift, and go to state 196
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200

    $default	reduce using rule 64 (leftpart_4prj)



state 163

    statement  ->  OPEN_BPAR leftpart_4prj . optional_projection CLOSE_BPAR PROJECTION OPEN_BPAR statement CLOSE_BPAR   (rule 60)

    COMMA	shift, and go to state 275

    $default	reduce using rule 69 (optional_projection)

    optional_projection	go to state 276



state 164

    statement  ->  FUNCTION ID . OPEN_PAR func_formal_par CLOSE_PAR OPEN_BPAR statement CLOSE_BPAR   (rule 62)

    OPEN_PAR	shift, and go to state 277



state 165

    basic_type  ->  UNSIGNED CHAR .   (rule 179)

    $default	reduce using rule 179 (basic_type)



state 166

    basic_type  ->  UNSIGNED SHORT .   (rule 182)

    $default	reduce using rule 182 (basic_type)



state 167

    basic_type  ->  UNSIGNED INT .   (rule 185)

    $default	reduce using rule 185 (basic_type)



state 168

    basic_type  ->  UNSIGNED LONG .   (rule 188)
    basic_type  ->  UNSIGNED LONG . LONG   (rule 191)

    LONG	shift, and go to state 278

    $default	reduce using rule 188 (basic_type)



state 169

    basic_type  ->  SIGNED CHAR .   (rule 178)

    $default	reduce using rule 178 (basic_type)



state 170

    basic_type  ->  SIGNED SHORT .   (rule 181)

    $default	reduce using rule 181 (basic_type)



state 171

    basic_type  ->  SIGNED INT .   (rule 184)

    $default	reduce using rule 184 (basic_type)



state 172

    basic_type  ->  SIGNED LONG .   (rule 187)
    basic_type  ->  SIGNED LONG . LONG   (rule 190)

    LONG	shift, and go to state 279

    $default	reduce using rule 187 (basic_type)



state 173

    unary_exp  ->  SIZEOF OPEN_PAR . basic_type CLOSE_PAR   (rule 140)
    unary_exp  ->  SIZEOF OPEN_PAR . basic_type pointer CLOSE_PAR   (rule 141)
    unary_exp  ->  SIZEOF OPEN_PAR . STRUCT_TYPE CLOSE_PAR   (rule 142)
    unary_exp  ->  SIZEOF OPEN_PAR . STRUCT_TYPE pointer CLOSE_PAR   (rule 143)
    unary_exp  ->  SIZEOF OPEN_PAR . bool_exp CLOSE_PAR   (rule 144)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    VOID	shift, and go to state 280
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 117
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 281
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    bool_exp	go to state 282
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 283
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 174

    declaration  ->  STRUCT . ID option_declaration   (rule 79)
    declaration  ->  STRUCT . STRUCT_TYPE option_declaration   (rule 81)

    ID  	shift, and go to state 284
    STRUCT_TYPE	shift, and go to state 139



state 175

    declaration  ->  UNION . ID option_declaration   (rule 80)
    declaration  ->  UNION . STRUCT_TYPE option_declaration   (rule 82)

    ID  	shift, and go to state 285
    STRUCT_TYPE	shift, and go to state 141



state 176

    primary_exp  ->  OPEN_PAR . exp CLOSE_PAR   (rule 155)
    identifier  ->  OPEN_PAR . identifier CLOSE_PAR   (rule 165)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    exp 	go to state 236
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 159
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 177

    statement  ->  EXTERN FUNCTION . ID OPEN_PAR func_formal_par CLOSE_PAR   (rule 36)

    ID  	shift, and go to state 286



state 178

    statement  ->  EXTERN declaration .   (rule 35)

    $default	reduce using rule 35 (statement)



state 179

    basic_exp  ->  basic_exp . DOT identifier   (rule 148)
    basic_exp  ->  basic_exp . IMPLY identifier   (rule 149)
    basic_exp  ->  basic_exp . OPEN_PAR func_actual_par CLOSE_PAR   (rule 150)
    basic_exp  ->  EXTERN basic_exp .   (rule 151)
    basic_exp  ->  basic_exp . OPEN_MPAR exp option_exp CLOSE_MPAR   (rule 152)

    DOT 	shift, and go to state 223
    OPEN_PAR	shift, and go to state 224
    OPEN_MPAR	shift, and go to state 225
    IMPLY	shift, and go to state 226

    DOT 	[reduce using rule 151 (basic_exp)]
    OPEN_PAR	[reduce using rule 151 (basic_exp)]
    OPEN_MPAR	[reduce using rule 151 (basic_exp)]
    IMPLY	[reduce using rule 151 (basic_exp)]
    $default	reduce using rule 151 (basic_exp)



state 180

    unary_exp  ->  ADDRESS unary_exp .   (rule 135)

    $default	reduce using rule 135 (unary_exp)



state 181

    unary_exp  ->  SUB unary_exp .   (rule 137)

    $default	reduce using rule 137 (unary_exp)



state 182

    unary_exp  ->  MUL unary_exp .   (rule 136)

    $default	reduce using rule 136 (unary_exp)



state 183

    unary_exp  ->  BNE unary_exp .   (rule 139)

    $default	reduce using rule 139 (unary_exp)



state 184

    statement  ->  NEXT OPEN_PAR . statement CLOSE_PAR   (rule 52)
    primary_exp  ->  OPEN_PAR . exp CLOSE_PAR   (rule 155)
    identifier  ->  OPEN_PAR . identifier CLOSE_PAR   (rule 165)
    type_cast  ->  OPEN_PAR . basic_type CLOSE_PAR   (rule 166)
    type_cast  ->  OPEN_PAR . basic_type pointer CLOSE_PAR   (rule 167)
    type_cast  ->  OPEN_PAR . STRUCT_TYPE CLOSE_PAR   (rule 168)
    type_cast  ->  OPEN_PAR . STRUCT_TYPE pointer CLOSE_PAR   (rule 169)
    type_cast  ->  OPEN_PAR . VOID OPEN_PAR pointer CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR CLOSE_PAR   (rule 170)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 155
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 156
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 287
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 158
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 159
    type_cast	go to state 97
    basic_type	go to state 160
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 185

    unary_exp  ->  NEXT unary_exp .   (rule 146)

    $default	reduce using rule 146 (unary_exp)



state 186

    unary_exp  ->  NEGATION unary_exp .   (rule 138)

    $default	reduce using rule 138 (unary_exp)



state 187

    statement  ->  LENGTH OPEN_PAR . ari_exp CLOSE_PAR   (rule 57)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    ari_exp	go to state 288
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 188

    input_statement  ->  REQUEST OPEN_PAR . exp option_exp CLOSE_PAR   (rule 236)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    exp 	go to state 289
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 189

    statement  ->  FINAL OPEN_PAR . statement CLOSE_PAR   (rule 58)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 290
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 190

    statement  ->  KEEP OPEN_PAR . statement CLOSE_PAR   (rule 53)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 291
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 191

    statement  ->  ALWAYS OPEN_PAR . statement CLOSE_PAR   (rule 54)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 292
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 192

    option_declaration  ->  OPEN_PAR . MUL identifier CLOSE_PAR OPEN_MPAR exp option_exp CLOSE_MPAR inner_option_declaration   (rule 93)
    identifier  ->  OPEN_PAR . identifier CLOSE_PAR   (rule 165)

    OPEN_PAR	shift, and go to state 142
    MUL 	shift, and go to state 293
    ID  	shift, and go to state 70

    identifier	go to state 249



state 193

    option_declaration  ->  MUL . option_declaration   (rule 92)

    OPEN_PAR	shift, and go to state 192
    MUL 	shift, and go to state 193
    ID  	shift, and go to state 70

    option_declaration	go to state 294
    identifier	go to state 195



state 194

    declaration  ->  STRUCT_TYPE option_declaration .   (rule 78)

    $default	reduce using rule 78 (declaration)



state 195

    option_declaration  ->  identifier . inner_option_declaration   (rule 84)
    option_declaration  ->  identifier . OPEN_MPAR exp option_exp CLOSE_MPAR inner_option_declaration   (rule 85)
    option_declaration  ->  identifier . ASS_P bool_exp inner_option_declaration   (rule 86)
    option_declaration  ->  identifier . ASS_P init_list inner_option_declaration   (rule 87)
    option_declaration  ->  identifier . ARRAY ASS_P init_list inner_option_declaration   (rule 88)
    option_declaration  ->  identifier . ARRAY ASS_P strliteral inner_option_declaration   (rule 89)
    option_declaration  ->  identifier . OPEN_MPAR exp option_exp CLOSE_MPAR ASS_P init_list inner_option_declaration   (rule 90)
    option_declaration  ->  identifier . OPEN_MPAR exp option_exp CLOSE_MPAR ASS_P strliteral inner_option_declaration   (rule 91)

    ARRAY	shift, and go to state 295
    OPEN_MPAR	shift, and go to state 296
    COMMA	shift, and go to state 297
    ASS_P	shift, and go to state 298

    ARRAY	[reduce using rule 96 (inner_option_declaration)]
    COMMA	[reduce using rule 96 (inner_option_declaration)]
    $default	reduce using rule 96 (inner_option_declaration)

    inner_option_declaration	go to state 299



state 196

    statement  ->  statement ARRAY . statement   (rule 31)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 300
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 197

    statement  ->  statement CHOP . statement   (rule 33)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 301
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 198

    statement  ->  statement OR . statement   (rule 30)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 302
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 199

    statement  ->  statement PARALLEL . statement   (rule 32)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 303
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 200

    statement  ->  statement AND . statement   (rule 29)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 304
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 201

    struct_define_statement  ->  struct_identifier OPEN_BPAR . option_struct_declaration CLOSE_BPAR   (rule 72)

    STRUCT	shift, and go to state 174
    UNION	shift, and go to state 175
    FILEDEC	shift, and go to state 28
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    STRUCT_TYPE	shift, and go to state 72

    option_struct_declaration	go to state 305
    declaration	go to state 306
    basic_type	go to state 98
    windows_type	go to state 99



state 202

    bool_exp  ->  bool_exp BOOL_OR . logic_and_exp   (rule 107)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    logic_and_exp	go to state 307
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 203

    logic_and_exp  ->  logic_and_exp BOOL_AND . bit_or_exp   (rule 109)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    bit_or_exp	go to state 308
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 204

    bit_or_exp  ->  bit_or_exp INTER_OR . bit_xor_exp   (rule 111)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    bit_xor_exp	go to state 309
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 205

    bit_xor_exp  ->  bit_xor_exp XOR . bit_and_exp   (rule 113)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    bit_and_exp	go to state 310
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 206

    bit_and_exp  ->  bit_and_exp ADDRESS . equlity_exp   (rule 115)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    equlity_exp	go to state 311
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 207

    equlity_exp  ->  equlity_exp NE . relation_exp   (rule 118)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    relation_exp	go to state 312
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 208

    equlity_exp  ->  equlity_exp EQ . relation_exp   (rule 117)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    relation_exp	go to state 313
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 209

    relation_exp  ->  relation_exp GE . ari_exp   (rule 121)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    ari_exp	go to state 314
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 210

    relation_exp  ->  relation_exp LE . ari_exp   (rule 123)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    ari_exp	go to state 315
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 211

    relation_exp  ->  relation_exp GT . ari_exp   (rule 120)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    ari_exp	go to state 316
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 212

    relation_exp  ->  relation_exp LT . ari_exp   (rule 122)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    ari_exp	go to state 317
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 213

    ari_exp  ->  ari_exp LST . add_exp   (rule 125)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    add_exp	go to state 318
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 214

    ari_exp  ->  ari_exp RST . add_exp   (rule 126)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    add_exp	go to state 319
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 215

    add_exp  ->  add_exp ADD . mul_exp   (rule 128)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    mul_exp	go to state 320
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 216

    add_exp  ->  add_exp SUB . mul_exp   (rule 129)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    mul_exp	go to state 321
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 217

    mul_exp  ->  mul_exp MUL . unary_exp   (rule 131)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    unary_exp	go to state 322
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 218

    mul_exp  ->  mul_exp DIV . unary_exp   (rule 132)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    unary_exp	go to state 323
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 219

    mul_exp  ->  mul_exp MOD . unary_exp   (rule 133)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    unary_exp	go to state 324
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 220

    assign_operator  ->  ASS_P .   (rule 103)

    $default	reduce using rule 103 (assign_operator)



state 221

    assign_operator  ->  ASS_N .   (rule 104)

    $default	reduce using rule 104 (assign_operator)



state 222

    ass_statement  ->  unary_exp assign_operator . exp   (rule 102)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    exp 	go to state 325
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 223

    basic_exp  ->  basic_exp DOT . identifier   (rule 148)

    OPEN_PAR	shift, and go to state 142
    ID  	shift, and go to state 70

    identifier	go to state 326



state 224

    basic_exp  ->  basic_exp OPEN_PAR . func_actual_par CLOSE_PAR   (rule 150)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    $default	reduce using rule 214 (func_actual_par)

    exp 	go to state 327
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    func_actual_par	go to state 328
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 225

    basic_exp  ->  basic_exp OPEN_MPAR . exp option_exp CLOSE_MPAR   (rule 152)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    exp 	go to state 329
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 226

    basic_exp  ->  basic_exp IMPLY . identifier   (rule 149)

    OPEN_PAR	shift, and go to state 142
    ID  	shift, and go to state 70

    identifier	go to state 330



state 227

    unary_exp  ->  type_cast unary_exp .   (rule 145)

    $default	reduce using rule 145 (unary_exp)



state 228

    declaration  ->  basic_type option_declaration .   (rule 77)

    $default	reduce using rule 77 (declaration)



state 229

    complexProposition  ->  DEFINE ID COLON . ari_exp   (rule 24)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    ari_exp	go to state 331
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 230

    complexProposition  ->  OPEN_PAR complexProposition CLOSE_PAR .   (rule 26)

    $default	reduce using rule 26 (complexProposition)



state 231

    poptional_projection  ->  COMMA . complexProposition poptional_projection   (rule 27)

    EMPTY	shift, and go to state 3
    DEFINE	shift, and go to state 4
    MY_TRUE	shift, and go to state 5
    MY_FALSE	shift, and go to state 6
    SKIP	shift, and go to state 7
    OPEN_PAR	shift, and go to state 8
    OPEN_BPAR	shift, and go to state 9
    NEXT	shift, and go to state 10
    NEGATION	shift, and go to state 11
    LENGTH	shift, and go to state 12
    FINAL	shift, and go to state 13
    KEEP	shift, and go to state 14
    ALWAYS	shift, and go to state 15
    HALT	shift, and go to state 16
    W_NEXT	shift, and go to state 17
    SOMETIMES	shift, and go to state 18
    ID  	shift, and go to state 19

    complexProposition	go to state 332



state 232

    complexProposition  ->  OPEN_BPAR complexProposition poptional_projection . CLOSE_BPAR PROJECTION OPEN_BPAR complexProposition CLOSE_BPAR   (rule 22)

    CLOSE_BPAR	shift, and go to state 333



state 233

    primary_exp  ->  IF exp . THEN exp ELSE exp   (rule 156)

    THEN	shift, and go to state 334



state 234

    type_cast  ->  OPEN_PAR VOID . OPEN_PAR pointer CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR CLOSE_PAR   (rule 170)
    basic_type  ->  VOID .   (rule 175)

    OPEN_PAR	shift, and go to state 335

    $default	reduce using rule 175 (basic_type)



state 235

    type_cast  ->  OPEN_PAR STRUCT_TYPE . CLOSE_PAR   (rule 168)
    type_cast  ->  OPEN_PAR STRUCT_TYPE . pointer CLOSE_PAR   (rule 169)

    CLOSE_PAR	shift, and go to state 265
    MUL 	shift, and go to state 336

    pointer	go to state 267



state 236

    primary_exp  ->  OPEN_PAR exp . CLOSE_PAR   (rule 155)

    CLOSE_PAR	shift, and go to state 269



state 237

    type_cast  ->  OPEN_PAR basic_type . CLOSE_PAR   (rule 166)
    type_cast  ->  OPEN_PAR basic_type . pointer CLOSE_PAR   (rule 167)

    CLOSE_PAR	shift, and go to state 271
    MUL 	shift, and go to state 336

    pointer	go to state 272



state 238

    complexProposition  ->  complexProposition . AND complexProposition   (rule 4)
    complexProposition  ->  complexProposition . OR complexProposition   (rule 5)
    complexProposition  ->  complexProposition . IFF complexProposition   (rule 6)
    complexProposition  ->  complexProposition . PROPIMPLY complexProposition   (rule 7)
    complexProposition  ->  complexProposition . CHOP complexProposition   (rule 8)
    complexProposition  ->  complexProposition CHOP complexProposition .   (rule 8)
    complexProposition  ->  complexProposition . CHOPSTAR   (rule 25)

    OR  	shift, and go to state 130
    AND 	shift, and go to state 131
    IFF 	shift, and go to state 132
    PROPIMPLY	shift, and go to state 133
    CHOPSTAR	shift, and go to state 134

    $default	reduce using rule 8 (complexProposition)



state 239

    complexProposition  ->  complexProposition . AND complexProposition   (rule 4)
    complexProposition  ->  complexProposition . OR complexProposition   (rule 5)
    complexProposition  ->  complexProposition OR complexProposition .   (rule 5)
    complexProposition  ->  complexProposition . IFF complexProposition   (rule 6)
    complexProposition  ->  complexProposition . PROPIMPLY complexProposition   (rule 7)
    complexProposition  ->  complexProposition . CHOP complexProposition   (rule 8)
    complexProposition  ->  complexProposition . CHOPSTAR   (rule 25)

    AND 	shift, and go to state 131
    IFF 	shift, and go to state 132
    PROPIMPLY	shift, and go to state 133
    CHOPSTAR	shift, and go to state 134

    $default	reduce using rule 5 (complexProposition)



state 240

    complexProposition  ->  complexProposition . AND complexProposition   (rule 4)
    complexProposition  ->  complexProposition AND complexProposition .   (rule 4)
    complexProposition  ->  complexProposition . OR complexProposition   (rule 5)
    complexProposition  ->  complexProposition . IFF complexProposition   (rule 6)
    complexProposition  ->  complexProposition . PROPIMPLY complexProposition   (rule 7)
    complexProposition  ->  complexProposition . CHOP complexProposition   (rule 8)
    complexProposition  ->  complexProposition . CHOPSTAR   (rule 25)

    IFF 	shift, and go to state 132
    PROPIMPLY	shift, and go to state 133
    CHOPSTAR	shift, and go to state 134

    $default	reduce using rule 4 (complexProposition)



state 241

    complexProposition  ->  complexProposition . AND complexProposition   (rule 4)
    complexProposition  ->  complexProposition . OR complexProposition   (rule 5)
    complexProposition  ->  complexProposition . IFF complexProposition   (rule 6)
    complexProposition  ->  complexProposition IFF complexProposition .   (rule 6)
    complexProposition  ->  complexProposition . PROPIMPLY complexProposition   (rule 7)
    complexProposition  ->  complexProposition . CHOP complexProposition   (rule 8)
    complexProposition  ->  complexProposition . CHOPSTAR   (rule 25)

    CHOPSTAR	shift, and go to state 134

    $default	reduce using rule 6 (complexProposition)



state 242

    complexProposition  ->  complexProposition . AND complexProposition   (rule 4)
    complexProposition  ->  complexProposition . OR complexProposition   (rule 5)
    complexProposition  ->  complexProposition . IFF complexProposition   (rule 6)
    complexProposition  ->  complexProposition . PROPIMPLY complexProposition   (rule 7)
    complexProposition  ->  complexProposition PROPIMPLY complexProposition .   (rule 7)
    complexProposition  ->  complexProposition . CHOP complexProposition   (rule 8)
    complexProposition  ->  complexProposition . CHOPSTAR   (rule 25)

    CHOPSTAR	shift, and go to state 134

    $default	reduce using rule 7 (complexProposition)



state 243

    primary_exp  ->  IF exp THEN . exp ELSE exp   (rule 156)
    if_statement  ->  IF exp THEN . OPEN_BPAR statement CLOSE_BPAR option_else_statement   (rule 232)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    OPEN_BPAR	shift, and go to state 337
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    exp 	go to state 338
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 244

    statement  ->  AWAIT OPEN_PAR bool_exp . CLOSE_PAR   (rule 55)
    bool_exp  ->  bool_exp . BOOL_OR logic_and_exp   (rule 107)

    CLOSE_PAR	shift, and go to state 339
    BOOL_OR	shift, and go to state 202



state 245

    declaration  ->  STRUCT ID option_declaration .   (rule 79)

    $default	reduce using rule 79 (declaration)



state 246

    declaration  ->  STRUCT STRUCT_TYPE option_declaration .   (rule 81)

    $default	reduce using rule 81 (declaration)



state 247

    declaration  ->  UNION ID option_declaration .   (rule 80)

    $default	reduce using rule 80 (declaration)



state 248

    declaration  ->  UNION STRUCT_TYPE option_declaration .   (rule 82)

    $default	reduce using rule 82 (declaration)



state 249

    identifier  ->  OPEN_PAR identifier . CLOSE_PAR   (rule 165)

    CLOSE_PAR	shift, and go to state 270



state 250

    inner_func_formal_par  ->  COMMA . func_formal_par   (rule 211)

    STRUCT	shift, and go to state 340
    FILEDEC	shift, and go to state 28
    VOID	shift, and go to state 341
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    STRUCT_TYPE	shift, and go to state 342

    $default	reduce using rule 205 (func_formal_par)

    basic_type	go to state 343
    windows_type	go to state 99
    func_formal_par	go to state 344



state 251

    statement  ->  EXIST identifier inner_func_formal_par . COLON OPEN_BPAR statement CLOSE_BPAR   (rule 61)

    COLON	shift, and go to state 345



state 252

    statement  ->  FRAME OPEN_PAR exp . option_exp CLOSE_PAR AND OPEN_PAR statement CLOSE_PAR   (rule 59)

    COMMA	shift, and go to state 346

    $default	reduce using rule 174 (option_exp)

    option_exp	go to state 347



state 253

    for_sta_init  ->  declaration .   (rule 226)

    $default	reduce using rule 226 (for_sta_init)



state 254

    for_sta_init  ->  ass_statement .   (rule 225)

    $default	reduce using rule 225 (for_sta_init)



state 255

    extend_for_statement  ->  FOR OPEN_PAR for_sta_init . COMMA for_sta_condition COMMA for_sta_control CLOSE_PAR OPEN_BPAR statement CLOSE_BPAR   (rule 224)

    COMMA	shift, and go to state 348



state 256

    for_statement  ->  FOR ari_exp TIMES . DO OPEN_BPAR statement CLOSE_BPAR   (rule 223)

    DO  	shift, and go to state 349



state 257

    bool_par  ->  error CLOSE_PAR .   (rule 216)

    $default	reduce using rule 216 (bool_par)



state 258

    bool_par  ->  OPEN_PAR exp . CLOSE_PAR   (rule 215)

    CLOSE_PAR	shift, and go to state 350



state 259

    while_statement  ->  WHILE bool_par OPEN_BPAR . statement CLOSE_BPAR   (rule 221)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 351
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 260

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)
    do_while_statement  ->  DO OPEN_BPAR statement . CLOSE_BPAR WHILE bool_par   (rule 222)

    ARRAY	shift, and go to state 196
    CLOSE_BPAR	shift, and go to state 352
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200



state 261

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)
    statement  ->  REPEAT OPEN_BPAR statement . CLOSE_BPAR UNTIL OPEN_PAR bool_exp CLOSE_PAR   (rule 56)

    ARRAY	shift, and go to state 196
    CLOSE_BPAR	shift, and go to state 353
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200



state 262

    output_statement  ->  DISPLAY OPEN_PAR exp . option_exp CLOSE_PAR   (rule 235)

    COMMA	shift, and go to state 346

    $default	reduce using rule 174 (option_exp)

    option_exp	go to state 354



state 263

    declaration  ->  VOID OPEN_PAR unary_exp . CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR   (rule 83)

    CLOSE_PAR	shift, and go to state 355



state 264

    declaration  ->  VOID OPEN_PAR . unary_exp CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR   (rule 83)
    type_cast  ->  OPEN_PAR VOID OPEN_PAR . pointer CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR CLOSE_PAR   (rule 170)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 356
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    unary_exp	go to state 263
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    pointer	go to state 357
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 265

    type_cast  ->  OPEN_PAR STRUCT_TYPE CLOSE_PAR .   (rule 168)

    $default	reduce using rule 168 (type_cast)



state 266

    option_declaration  ->  MUL . option_declaration   (rule 92)
    pointer  ->  MUL .   (rule 171)
    pointer  ->  MUL . pointer   (rule 172)

    OPEN_PAR	shift, and go to state 192
    MUL 	shift, and go to state 266
    ID  	shift, and go to state 70

    $default	reduce using rule 171 (pointer)

    option_declaration	go to state 294
    identifier	go to state 195
    pointer	go to state 358



state 267

    type_cast  ->  OPEN_PAR STRUCT_TYPE pointer . CLOSE_PAR   (rule 169)

    CLOSE_PAR	shift, and go to state 359



state 268

    statement  ->  OPEN_PAR statement CLOSE_PAR .   (rule 63)

    $default	reduce using rule 63 (statement)



state 269

    primary_exp  ->  OPEN_PAR exp CLOSE_PAR .   (rule 155)

    $default	reduce using rule 155 (primary_exp)



state 270

    identifier  ->  OPEN_PAR identifier CLOSE_PAR .   (rule 165)

    $default	reduce using rule 165 (identifier)



state 271

    type_cast  ->  OPEN_PAR basic_type CLOSE_PAR .   (rule 166)

    $default	reduce using rule 166 (type_cast)



state 272

    type_cast  ->  OPEN_PAR basic_type pointer . CLOSE_PAR   (rule 167)

    CLOSE_PAR	shift, and go to state 360



state 273

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)
    statement  ->  OPEN_PAR statement . CLOSE_PAR   (rule 63)
    leftpart_4prj  ->  statement .   (rule 64)
    leftpart_4prj  ->  OPEN_PAR statement . CLOSE_PAR XOR ari_exp   (rule 65)

    ARRAY	shift, and go to state 196
    CLOSE_PAR	shift, and go to state 361
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200

    CLOSE_PAR	[reduce using rule 64 (leftpart_4prj)]
    $default	reduce using rule 64 (leftpart_4prj)



state 274

    leftpart_4prj  ->  OPEN_PAR leftpart_4prj . optional_leftpart_4prj CLOSE_PAR XOR ari_exp   (rule 66)

    COMMA	shift, and go to state 362

    $default	reduce using rule 67 (optional_leftpart_4prj)

    optional_leftpart_4prj	go to state 363



state 275

    optional_projection  ->  COMMA . leftpart_4prj optional_projection   (rule 70)
    optional_projection  ->  COMMA . error   (rule 71)

    error	shift, and go to state 364
    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 161
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 162
    leftpart_4prj	go to state 365
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 276

    statement  ->  OPEN_BPAR leftpart_4prj optional_projection . CLOSE_BPAR PROJECTION OPEN_BPAR statement CLOSE_BPAR   (rule 60)

    CLOSE_BPAR	shift, and go to state 366



state 277

    statement  ->  FUNCTION ID OPEN_PAR . func_formal_par CLOSE_PAR OPEN_BPAR statement CLOSE_BPAR   (rule 62)

    STRUCT	shift, and go to state 340
    FILEDEC	shift, and go to state 28
    VOID	shift, and go to state 341
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    STRUCT_TYPE	shift, and go to state 342

    $default	reduce using rule 205 (func_formal_par)

    basic_type	go to state 343
    windows_type	go to state 99
    func_formal_par	go to state 367



state 278

    basic_type  ->  UNSIGNED LONG LONG .   (rule 191)

    $default	reduce using rule 191 (basic_type)



state 279

    basic_type  ->  SIGNED LONG LONG .   (rule 190)

    $default	reduce using rule 190 (basic_type)



state 280

    basic_type  ->  VOID .   (rule 175)

    $default	reduce using rule 175 (basic_type)



state 281

    unary_exp  ->  SIZEOF OPEN_PAR STRUCT_TYPE . CLOSE_PAR   (rule 142)
    unary_exp  ->  SIZEOF OPEN_PAR STRUCT_TYPE . pointer CLOSE_PAR   (rule 143)

    CLOSE_PAR	shift, and go to state 368
    MUL 	shift, and go to state 336

    pointer	go to state 369



state 282

    bool_exp  ->  bool_exp . BOOL_OR logic_and_exp   (rule 107)
    unary_exp  ->  SIZEOF OPEN_PAR bool_exp . CLOSE_PAR   (rule 144)

    CLOSE_PAR	shift, and go to state 370
    BOOL_OR	shift, and go to state 202



state 283

    unary_exp  ->  SIZEOF OPEN_PAR basic_type . CLOSE_PAR   (rule 140)
    unary_exp  ->  SIZEOF OPEN_PAR basic_type . pointer CLOSE_PAR   (rule 141)

    CLOSE_PAR	shift, and go to state 371
    MUL 	shift, and go to state 336

    pointer	go to state 372



state 284

    declaration  ->  STRUCT ID . option_declaration   (rule 79)

    OPEN_PAR	shift, and go to state 192
    MUL 	shift, and go to state 193
    ID  	shift, and go to state 70

    option_declaration	go to state 245
    identifier	go to state 195



state 285

    declaration  ->  UNION ID . option_declaration   (rule 80)

    OPEN_PAR	shift, and go to state 192
    MUL 	shift, and go to state 193
    ID  	shift, and go to state 70

    option_declaration	go to state 247
    identifier	go to state 195



state 286

    statement  ->  EXTERN FUNCTION ID . OPEN_PAR func_formal_par CLOSE_PAR   (rule 36)

    OPEN_PAR	shift, and go to state 373



state 287

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)
    statement  ->  NEXT OPEN_PAR statement . CLOSE_PAR   (rule 52)

    ARRAY	shift, and go to state 196
    CLOSE_PAR	shift, and go to state 374
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200



state 288

    statement  ->  LENGTH OPEN_PAR ari_exp . CLOSE_PAR   (rule 57)
    ari_exp  ->  ari_exp . LST add_exp   (rule 125)
    ari_exp  ->  ari_exp . RST add_exp   (rule 126)

    CLOSE_PAR	shift, and go to state 375
    LST 	shift, and go to state 213
    RST 	shift, and go to state 214



state 289

    input_statement  ->  REQUEST OPEN_PAR exp . option_exp CLOSE_PAR   (rule 236)

    COMMA	shift, and go to state 346

    $default	reduce using rule 174 (option_exp)

    option_exp	go to state 376



state 290

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)
    statement  ->  FINAL OPEN_PAR statement . CLOSE_PAR   (rule 58)

    ARRAY	shift, and go to state 196
    CLOSE_PAR	shift, and go to state 377
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200



state 291

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)
    statement  ->  KEEP OPEN_PAR statement . CLOSE_PAR   (rule 53)

    ARRAY	shift, and go to state 196
    CLOSE_PAR	shift, and go to state 378
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200



state 292

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)
    statement  ->  ALWAYS OPEN_PAR statement . CLOSE_PAR   (rule 54)

    ARRAY	shift, and go to state 196
    CLOSE_PAR	shift, and go to state 379
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200



state 293

    option_declaration  ->  OPEN_PAR MUL . identifier CLOSE_PAR OPEN_MPAR exp option_exp CLOSE_MPAR inner_option_declaration   (rule 93)

    OPEN_PAR	shift, and go to state 142
    ID  	shift, and go to state 70

    identifier	go to state 380



state 294

    option_declaration  ->  MUL option_declaration .   (rule 92)

    $default	reduce using rule 92 (option_declaration)



state 295

    option_declaration  ->  identifier ARRAY . ASS_P init_list inner_option_declaration   (rule 88)
    option_declaration  ->  identifier ARRAY . ASS_P strliteral inner_option_declaration   (rule 89)

    ASS_P	shift, and go to state 381



state 296

    option_declaration  ->  identifier OPEN_MPAR . exp option_exp CLOSE_MPAR inner_option_declaration   (rule 85)
    option_declaration  ->  identifier OPEN_MPAR . exp option_exp CLOSE_MPAR ASS_P init_list inner_option_declaration   (rule 90)
    option_declaration  ->  identifier OPEN_MPAR . exp option_exp CLOSE_MPAR ASS_P strliteral inner_option_declaration   (rule 91)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    exp 	go to state 382
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 297

    inner_option_declaration  ->  COMMA . option_declaration   (rule 94)
    inner_option_declaration  ->  COMMA . error   (rule 95)

    error	shift, and go to state 383
    OPEN_PAR	shift, and go to state 192
    MUL 	shift, and go to state 193
    ID  	shift, and go to state 70

    option_declaration	go to state 384
    identifier	go to state 195



state 298

    option_declaration  ->  identifier ASS_P . bool_exp inner_option_declaration   (rule 86)
    option_declaration  ->  identifier ASS_P . init_list inner_option_declaration   (rule 87)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    OPEN_BPAR	shift, and go to state 385
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    init_list	go to state 386
    bool_exp	go to state 387
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 299

    option_declaration  ->  identifier inner_option_declaration .   (rule 84)

    $default	reduce using rule 84 (option_declaration)



state 300

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement ARRAY statement .   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)

    ARRAY	shift, and go to state 196
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200

    ARRAY	[reduce using rule 31 (statement)]
    CHOP	[reduce using rule 31 (statement)]
    OR  	[reduce using rule 31 (statement)]
    PARALLEL	[reduce using rule 31 (statement)]
    AND 	[reduce using rule 31 (statement)]
    $default	reduce using rule 31 (statement)



state 301

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)
    statement  ->  statement CHOP statement .   (rule 33)

    ARRAY	shift, and go to state 196
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200

    ARRAY	[reduce using rule 33 (statement)]
    $default	reduce using rule 33 (statement)



state 302

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement OR statement .   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)

    ARRAY	shift, and go to state 196
    AND 	shift, and go to state 200

    ARRAY	[reduce using rule 30 (statement)]
    $default	reduce using rule 30 (statement)



state 303

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement PARALLEL statement .   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)

    ARRAY	shift, and go to state 196
    AND 	shift, and go to state 200

    ARRAY	[reduce using rule 32 (statement)]
    $default	reduce using rule 32 (statement)



state 304

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement AND statement .   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)

    ARRAY	shift, and go to state 196

    ARRAY	[reduce using rule 29 (statement)]
    $default	reduce using rule 29 (statement)



state 305

    struct_define_statement  ->  struct_identifier OPEN_BPAR option_struct_declaration . CLOSE_BPAR   (rule 72)

    CLOSE_BPAR	shift, and go to state 388



state 306

    option_struct_declaration  ->  declaration .   (rule 73)
    option_struct_declaration  ->  declaration . AND option_struct_declaration   (rule 74)

    AND 	shift, and go to state 389

    $default	reduce using rule 73 (option_struct_declaration)



state 307

    bool_exp  ->  bool_exp BOOL_OR logic_and_exp .   (rule 107)
    logic_and_exp  ->  logic_and_exp . BOOL_AND bit_or_exp   (rule 109)

    BOOL_AND	shift, and go to state 203

    $default	reduce using rule 107 (bool_exp)



state 308

    logic_and_exp  ->  logic_and_exp BOOL_AND bit_or_exp .   (rule 109)
    bit_or_exp  ->  bit_or_exp . INTER_OR bit_xor_exp   (rule 111)

    INTER_OR	shift, and go to state 204

    INTER_OR	[reduce using rule 109 (logic_and_exp)]
    $default	reduce using rule 109 (logic_and_exp)



state 309

    bit_or_exp  ->  bit_or_exp INTER_OR bit_xor_exp .   (rule 111)
    bit_xor_exp  ->  bit_xor_exp . XOR bit_and_exp   (rule 113)

    XOR 	shift, and go to state 205

    XOR 	[reduce using rule 111 (bit_or_exp)]
    $default	reduce using rule 111 (bit_or_exp)



state 310

    bit_xor_exp  ->  bit_xor_exp XOR bit_and_exp .   (rule 113)
    bit_and_exp  ->  bit_and_exp . ADDRESS equlity_exp   (rule 115)

    ADDRESS	shift, and go to state 206

    $default	reduce using rule 113 (bit_xor_exp)



state 311

    bit_and_exp  ->  bit_and_exp ADDRESS equlity_exp .   (rule 115)
    equlity_exp  ->  equlity_exp . EQ relation_exp   (rule 117)
    equlity_exp  ->  equlity_exp . NE relation_exp   (rule 118)

    NE  	shift, and go to state 207
    EQ  	shift, and go to state 208

    $default	reduce using rule 115 (bit_and_exp)



state 312

    equlity_exp  ->  equlity_exp NE relation_exp .   (rule 118)
    relation_exp  ->  relation_exp . GT ari_exp   (rule 120)
    relation_exp  ->  relation_exp . GE ari_exp   (rule 121)
    relation_exp  ->  relation_exp . LT ari_exp   (rule 122)
    relation_exp  ->  relation_exp . LE ari_exp   (rule 123)

    GE  	shift, and go to state 209
    LE  	shift, and go to state 210
    GT  	shift, and go to state 211
    LT  	shift, and go to state 212

    $default	reduce using rule 118 (equlity_exp)



state 313

    equlity_exp  ->  equlity_exp EQ relation_exp .   (rule 117)
    relation_exp  ->  relation_exp . GT ari_exp   (rule 120)
    relation_exp  ->  relation_exp . GE ari_exp   (rule 121)
    relation_exp  ->  relation_exp . LT ari_exp   (rule 122)
    relation_exp  ->  relation_exp . LE ari_exp   (rule 123)

    GE  	shift, and go to state 209
    LE  	shift, and go to state 210
    GT  	shift, and go to state 211
    LT  	shift, and go to state 212

    $default	reduce using rule 117 (equlity_exp)



state 314

    relation_exp  ->  relation_exp GE ari_exp .   (rule 121)
    ari_exp  ->  ari_exp . LST add_exp   (rule 125)
    ari_exp  ->  ari_exp . RST add_exp   (rule 126)

    LST 	shift, and go to state 213
    RST 	shift, and go to state 214

    $default	reduce using rule 121 (relation_exp)



state 315

    relation_exp  ->  relation_exp LE ari_exp .   (rule 123)
    ari_exp  ->  ari_exp . LST add_exp   (rule 125)
    ari_exp  ->  ari_exp . RST add_exp   (rule 126)

    LST 	shift, and go to state 213
    RST 	shift, and go to state 214

    $default	reduce using rule 123 (relation_exp)



state 316

    relation_exp  ->  relation_exp GT ari_exp .   (rule 120)
    ari_exp  ->  ari_exp . LST add_exp   (rule 125)
    ari_exp  ->  ari_exp . RST add_exp   (rule 126)

    LST 	shift, and go to state 213
    RST 	shift, and go to state 214

    $default	reduce using rule 120 (relation_exp)



state 317

    relation_exp  ->  relation_exp LT ari_exp .   (rule 122)
    ari_exp  ->  ari_exp . LST add_exp   (rule 125)
    ari_exp  ->  ari_exp . RST add_exp   (rule 126)

    LST 	shift, and go to state 213
    RST 	shift, and go to state 214

    $default	reduce using rule 122 (relation_exp)



state 318

    ari_exp  ->  ari_exp LST add_exp .   (rule 125)
    add_exp  ->  add_exp . ADD mul_exp   (rule 128)
    add_exp  ->  add_exp . SUB mul_exp   (rule 129)

    ADD 	shift, and go to state 215
    SUB 	shift, and go to state 216

    $default	reduce using rule 125 (ari_exp)



state 319

    ari_exp  ->  ari_exp RST add_exp .   (rule 126)
    add_exp  ->  add_exp . ADD mul_exp   (rule 128)
    add_exp  ->  add_exp . SUB mul_exp   (rule 129)

    ADD 	shift, and go to state 215
    SUB 	shift, and go to state 216

    $default	reduce using rule 126 (ari_exp)



state 320

    add_exp  ->  add_exp ADD mul_exp .   (rule 128)
    mul_exp  ->  mul_exp . MUL unary_exp   (rule 131)
    mul_exp  ->  mul_exp . DIV unary_exp   (rule 132)
    mul_exp  ->  mul_exp . MOD unary_exp   (rule 133)

    MUL 	shift, and go to state 217
    DIV 	shift, and go to state 218
    MOD 	shift, and go to state 219

    $default	reduce using rule 128 (add_exp)



state 321

    add_exp  ->  add_exp SUB mul_exp .   (rule 129)
    mul_exp  ->  mul_exp . MUL unary_exp   (rule 131)
    mul_exp  ->  mul_exp . DIV unary_exp   (rule 132)
    mul_exp  ->  mul_exp . MOD unary_exp   (rule 133)

    MUL 	shift, and go to state 217
    DIV 	shift, and go to state 218
    MOD 	shift, and go to state 219

    $default	reduce using rule 129 (add_exp)



state 322

    mul_exp  ->  mul_exp MUL unary_exp .   (rule 131)

    $default	reduce using rule 131 (mul_exp)



state 323

    mul_exp  ->  mul_exp DIV unary_exp .   (rule 132)

    $default	reduce using rule 132 (mul_exp)



state 324

    mul_exp  ->  mul_exp MOD unary_exp .   (rule 133)

    $default	reduce using rule 133 (mul_exp)



state 325

    ass_statement  ->  unary_exp assign_operator exp .   (rule 102)

    $default	reduce using rule 102 (ass_statement)



state 326

    basic_exp  ->  basic_exp DOT identifier .   (rule 148)

    $default	reduce using rule 148 (basic_exp)



state 327

    func_actual_par  ->  exp . option_exp   (rule 213)

    COMMA	shift, and go to state 346

    $default	reduce using rule 174 (option_exp)

    option_exp	go to state 390



state 328

    basic_exp  ->  basic_exp OPEN_PAR func_actual_par . CLOSE_PAR   (rule 150)

    CLOSE_PAR	shift, and go to state 391



state 329

    basic_exp  ->  basic_exp OPEN_MPAR exp . option_exp CLOSE_MPAR   (rule 152)

    COMMA	shift, and go to state 346

    $default	reduce using rule 174 (option_exp)

    option_exp	go to state 392



state 330

    basic_exp  ->  basic_exp IMPLY identifier .   (rule 149)

    $default	reduce using rule 149 (basic_exp)



state 331

    complexProposition  ->  DEFINE ID COLON ari_exp .   (rule 24)
    ari_exp  ->  ari_exp . LST add_exp   (rule 125)
    ari_exp  ->  ari_exp . RST add_exp   (rule 126)

    LST 	shift, and go to state 213
    RST 	shift, and go to state 214

    $default	reduce using rule 24 (complexProposition)



state 332

    complexProposition  ->  complexProposition . AND complexProposition   (rule 4)
    complexProposition  ->  complexProposition . OR complexProposition   (rule 5)
    complexProposition  ->  complexProposition . IFF complexProposition   (rule 6)
    complexProposition  ->  complexProposition . PROPIMPLY complexProposition   (rule 7)
    complexProposition  ->  complexProposition . CHOP complexProposition   (rule 8)
    complexProposition  ->  complexProposition . CHOPSTAR   (rule 25)
    poptional_projection  ->  COMMA complexProposition . poptional_projection   (rule 27)

    COMMA	shift, and go to state 231
    CHOP	shift, and go to state 129
    OR  	shift, and go to state 130
    AND 	shift, and go to state 131
    IFF 	shift, and go to state 132
    PROPIMPLY	shift, and go to state 133
    CHOPSTAR	shift, and go to state 134

    $default	reduce using rule 28 (poptional_projection)

    poptional_projection	go to state 393



state 333

    complexProposition  ->  OPEN_BPAR complexProposition poptional_projection CLOSE_BPAR . PROJECTION OPEN_BPAR complexProposition CLOSE_BPAR   (rule 22)

    PROJECTION	shift, and go to state 394



state 334

    primary_exp  ->  IF exp THEN . exp ELSE exp   (rule 156)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    exp 	go to state 338
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 335

    type_cast  ->  OPEN_PAR VOID OPEN_PAR . pointer CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR CLOSE_PAR   (rule 170)

    MUL 	shift, and go to state 336

    pointer	go to state 357



state 336

    pointer  ->  MUL .   (rule 171)
    pointer  ->  MUL . pointer   (rule 172)

    MUL 	shift, and go to state 336

    $default	reduce using rule 171 (pointer)

    pointer	go to state 358



state 337

    if_statement  ->  IF exp THEN OPEN_BPAR . statement CLOSE_BPAR option_else_statement   (rule 232)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 395
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 338

    primary_exp  ->  IF exp THEN exp . ELSE exp   (rule 156)

    ELSE	shift, and go to state 396



state 339

    statement  ->  AWAIT OPEN_PAR bool_exp CLOSE_PAR .   (rule 55)

    $default	reduce using rule 55 (statement)



state 340

    func_formal_par  ->  STRUCT . ID option_formal_par inner_func_formal_par   (rule 201)
    func_formal_par  ->  STRUCT . STRUCT_TYPE option_formal_par inner_func_formal_par   (rule 202)

    ID  	shift, and go to state 397
    STRUCT_TYPE	shift, and go to state 398



state 341

    basic_type  ->  VOID .   (rule 175)
    func_formal_par  ->  VOID . OPEN_PAR unary_exp CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR inner_func_formal_par   (rule 203)
    func_formal_par  ->  VOID . OPEN_PAR unary_exp ARRAY CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR inner_func_formal_par   (rule 204)

    OPEN_PAR	shift, and go to state 399

    OPEN_PAR	[reduce using rule 175 (basic_type)]
    $default	reduce using rule 175 (basic_type)



state 342

    func_formal_par  ->  STRUCT_TYPE . option_formal_par inner_func_formal_par   (rule 200)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 176
    EXTERN	shift, and go to state 118
    MUL 	shift, and go to state 400
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    $default	reduce using rule 210 (option_formal_par)

    basic_exp	go to state 401
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 402
    option_formal_par	go to state 403
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 343

    func_formal_par  ->  basic_type . option_formal_par inner_func_formal_par   (rule 199)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 176
    EXTERN	shift, and go to state 118
    MUL 	shift, and go to state 400
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    $default	reduce using rule 210 (option_formal_par)

    basic_exp	go to state 401
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 402
    option_formal_par	go to state 404
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 344

    inner_func_formal_par  ->  COMMA func_formal_par .   (rule 211)

    $default	reduce using rule 211 (inner_func_formal_par)



state 345

    statement  ->  EXIST identifier inner_func_formal_par COLON . OPEN_BPAR statement CLOSE_BPAR   (rule 61)

    OPEN_BPAR	shift, and go to state 405



state 346

    option_exp  ->  COMMA . exp option_exp   (rule 173)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    exp 	go to state 406
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 347

    statement  ->  FRAME OPEN_PAR exp option_exp . CLOSE_PAR AND OPEN_PAR statement CLOSE_PAR   (rule 59)

    CLOSE_PAR	shift, and go to state 407



state 348

    extend_for_statement  ->  FOR OPEN_PAR for_sta_init COMMA . for_sta_condition COMMA for_sta_control CLOSE_PAR OPEN_BPAR statement CLOSE_BPAR   (rule 224)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    $default	reduce using rule 229 (for_sta_condition)

    bool_exp	go to state 408
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    for_sta_condition	go to state 409



state 349

    for_statement  ->  FOR ari_exp TIMES DO . OPEN_BPAR statement CLOSE_BPAR   (rule 223)

    OPEN_BPAR	shift, and go to state 410



state 350

    bool_par  ->  OPEN_PAR exp CLOSE_PAR .   (rule 215)

    $default	reduce using rule 215 (bool_par)



state 351

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)
    while_statement  ->  WHILE bool_par OPEN_BPAR statement . CLOSE_BPAR   (rule 221)

    ARRAY	shift, and go to state 196
    CLOSE_BPAR	shift, and go to state 411
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200



state 352

    do_while_statement  ->  DO OPEN_BPAR statement CLOSE_BPAR . WHILE bool_par   (rule 222)

    WHILE	shift, and go to state 412



state 353

    statement  ->  REPEAT OPEN_BPAR statement CLOSE_BPAR . UNTIL OPEN_PAR bool_exp CLOSE_PAR   (rule 56)

    UNTIL	shift, and go to state 413



state 354

    output_statement  ->  DISPLAY OPEN_PAR exp option_exp . CLOSE_PAR   (rule 235)

    CLOSE_PAR	shift, and go to state 414



state 355

    declaration  ->  VOID OPEN_PAR unary_exp CLOSE_PAR . OPEN_PAR func_formal_par CLOSE_PAR   (rule 83)

    OPEN_PAR	shift, and go to state 415



state 356

    unary_exp  ->  MUL . unary_exp   (rule 136)
    pointer  ->  MUL .   (rule 171)
    pointer  ->  MUL . pointer   (rule 172)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 356
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    $default	reduce using rule 171 (pointer)

    unary_exp	go to state 182
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    pointer	go to state 358
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 357

    type_cast  ->  OPEN_PAR VOID OPEN_PAR pointer . CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR CLOSE_PAR   (rule 170)

    CLOSE_PAR	shift, and go to state 416



state 358

    pointer  ->  MUL pointer .   (rule 172)

    $default	reduce using rule 172 (pointer)



state 359

    type_cast  ->  OPEN_PAR STRUCT_TYPE pointer CLOSE_PAR .   (rule 169)

    $default	reduce using rule 169 (type_cast)



state 360

    type_cast  ->  OPEN_PAR basic_type pointer CLOSE_PAR .   (rule 167)

    $default	reduce using rule 167 (type_cast)



state 361

    statement  ->  OPEN_PAR statement CLOSE_PAR .   (rule 63)
    leftpart_4prj  ->  OPEN_PAR statement CLOSE_PAR . XOR ari_exp   (rule 65)

    XOR 	shift, and go to state 417

    $default	reduce using rule 63 (statement)



state 362

    optional_leftpart_4prj  ->  COMMA . leftpart_4prj optional_leftpart_4prj   (rule 68)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 161
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 162
    leftpart_4prj	go to state 418
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 363

    leftpart_4prj  ->  OPEN_PAR leftpart_4prj optional_leftpart_4prj . CLOSE_PAR XOR ari_exp   (rule 66)

    CLOSE_PAR	shift, and go to state 419



state 364

    optional_projection  ->  COMMA error .   (rule 71)

    $default	reduce using rule 71 (optional_projection)



state 365

    optional_projection  ->  COMMA leftpart_4prj . optional_projection   (rule 70)

    COMMA	shift, and go to state 275

    $default	reduce using rule 69 (optional_projection)

    optional_projection	go to state 420



state 366

    statement  ->  OPEN_BPAR leftpart_4prj optional_projection CLOSE_BPAR . PROJECTION OPEN_BPAR statement CLOSE_BPAR   (rule 60)

    PROJECTION	shift, and go to state 421



state 367

    statement  ->  FUNCTION ID OPEN_PAR func_formal_par . CLOSE_PAR OPEN_BPAR statement CLOSE_BPAR   (rule 62)

    CLOSE_PAR	shift, and go to state 422



state 368

    unary_exp  ->  SIZEOF OPEN_PAR STRUCT_TYPE CLOSE_PAR .   (rule 142)

    $default	reduce using rule 142 (unary_exp)



state 369

    unary_exp  ->  SIZEOF OPEN_PAR STRUCT_TYPE pointer . CLOSE_PAR   (rule 143)

    CLOSE_PAR	shift, and go to state 423



state 370

    unary_exp  ->  SIZEOF OPEN_PAR bool_exp CLOSE_PAR .   (rule 144)

    $default	reduce using rule 144 (unary_exp)



state 371

    unary_exp  ->  SIZEOF OPEN_PAR basic_type CLOSE_PAR .   (rule 140)

    $default	reduce using rule 140 (unary_exp)



state 372

    unary_exp  ->  SIZEOF OPEN_PAR basic_type pointer . CLOSE_PAR   (rule 141)

    CLOSE_PAR	shift, and go to state 424



state 373

    statement  ->  EXTERN FUNCTION ID OPEN_PAR . func_formal_par CLOSE_PAR   (rule 36)

    STRUCT	shift, and go to state 340
    FILEDEC	shift, and go to state 28
    VOID	shift, and go to state 341
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    STRUCT_TYPE	shift, and go to state 342

    $default	reduce using rule 205 (func_formal_par)

    basic_type	go to state 343
    windows_type	go to state 99
    func_formal_par	go to state 425



state 374

    statement  ->  NEXT OPEN_PAR statement CLOSE_PAR .   (rule 52)

    $default	reduce using rule 52 (statement)



state 375

    statement  ->  LENGTH OPEN_PAR ari_exp CLOSE_PAR .   (rule 57)

    $default	reduce using rule 57 (statement)



state 376

    input_statement  ->  REQUEST OPEN_PAR exp option_exp . CLOSE_PAR   (rule 236)

    CLOSE_PAR	shift, and go to state 426



state 377

    statement  ->  FINAL OPEN_PAR statement CLOSE_PAR .   (rule 58)

    $default	reduce using rule 58 (statement)



state 378

    statement  ->  KEEP OPEN_PAR statement CLOSE_PAR .   (rule 53)

    $default	reduce using rule 53 (statement)



state 379

    statement  ->  ALWAYS OPEN_PAR statement CLOSE_PAR .   (rule 54)

    $default	reduce using rule 54 (statement)



state 380

    option_declaration  ->  OPEN_PAR MUL identifier . CLOSE_PAR OPEN_MPAR exp option_exp CLOSE_MPAR inner_option_declaration   (rule 93)

    CLOSE_PAR	shift, and go to state 427



state 381

    option_declaration  ->  identifier ARRAY ASS_P . init_list inner_option_declaration   (rule 88)
    option_declaration  ->  identifier ARRAY ASS_P . strliteral inner_option_declaration   (rule 89)

    OPEN_BPAR	shift, and go to state 385
    STRLITERAL	shift, and go to state 71

    init_list	go to state 428
    strliteral	go to state 429



state 382

    option_declaration  ->  identifier OPEN_MPAR exp . option_exp CLOSE_MPAR inner_option_declaration   (rule 85)
    option_declaration  ->  identifier OPEN_MPAR exp . option_exp CLOSE_MPAR ASS_P init_list inner_option_declaration   (rule 90)
    option_declaration  ->  identifier OPEN_MPAR exp . option_exp CLOSE_MPAR ASS_P strliteral inner_option_declaration   (rule 91)

    COMMA	shift, and go to state 346

    $default	reduce using rule 174 (option_exp)

    option_exp	go to state 430



state 383

    inner_option_declaration  ->  COMMA error .   (rule 95)

    $default	reduce using rule 95 (inner_option_declaration)



state 384

    inner_option_declaration  ->  COMMA option_declaration .   (rule 94)

    $default	reduce using rule 94 (inner_option_declaration)



state 385

    init_list  ->  OPEN_BPAR . init_exp CLOSE_BPAR   (rule 97)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    OPEN_BPAR	shift, and go to state 385
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    init_list	go to state 431
    init_exp	go to state 432
    bool_exp	go to state 433
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 386

    option_declaration  ->  identifier ASS_P init_list . inner_option_declaration   (rule 87)

    COMMA	shift, and go to state 297

    COMMA	[reduce using rule 96 (inner_option_declaration)]
    $default	reduce using rule 96 (inner_option_declaration)

    inner_option_declaration	go to state 434



state 387

    option_declaration  ->  identifier ASS_P bool_exp . inner_option_declaration   (rule 86)
    bool_exp  ->  bool_exp . BOOL_OR logic_and_exp   (rule 107)

    COMMA	shift, and go to state 297
    BOOL_OR	shift, and go to state 202

    COMMA	[reduce using rule 96 (inner_option_declaration)]
    $default	reduce using rule 96 (inner_option_declaration)

    inner_option_declaration	go to state 435



state 388

    struct_define_statement  ->  struct_identifier OPEN_BPAR option_struct_declaration CLOSE_BPAR .   (rule 72)

    $default	reduce using rule 72 (struct_define_statement)



state 389

    option_struct_declaration  ->  declaration AND . option_struct_declaration   (rule 74)

    STRUCT	shift, and go to state 174
    UNION	shift, and go to state 175
    FILEDEC	shift, and go to state 28
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    STRUCT_TYPE	shift, and go to state 72

    option_struct_declaration	go to state 436
    declaration	go to state 306
    basic_type	go to state 98
    windows_type	go to state 99



state 390

    func_actual_par  ->  exp option_exp .   (rule 213)

    $default	reduce using rule 213 (func_actual_par)



state 391

    basic_exp  ->  basic_exp OPEN_PAR func_actual_par CLOSE_PAR .   (rule 150)

    $default	reduce using rule 150 (basic_exp)



state 392

    basic_exp  ->  basic_exp OPEN_MPAR exp option_exp . CLOSE_MPAR   (rule 152)

    CLOSE_MPAR	shift, and go to state 437



state 393

    poptional_projection  ->  COMMA complexProposition poptional_projection .   (rule 27)

    $default	reduce using rule 27 (poptional_projection)



state 394

    complexProposition  ->  OPEN_BPAR complexProposition poptional_projection CLOSE_BPAR PROJECTION . OPEN_BPAR complexProposition CLOSE_BPAR   (rule 22)

    OPEN_BPAR	shift, and go to state 438



state 395

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)
    if_statement  ->  IF exp THEN OPEN_BPAR statement . CLOSE_BPAR option_else_statement   (rule 232)

    ARRAY	shift, and go to state 196
    CLOSE_BPAR	shift, and go to state 439
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200



state 396

    primary_exp  ->  IF exp THEN exp ELSE . exp   (rule 156)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    exp 	go to state 440
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 397

    func_formal_par  ->  STRUCT ID . option_formal_par inner_func_formal_par   (rule 201)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 176
    EXTERN	shift, and go to state 118
    MUL 	shift, and go to state 400
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    $default	reduce using rule 210 (option_formal_par)

    basic_exp	go to state 401
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 402
    option_formal_par	go to state 441
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 398

    func_formal_par  ->  STRUCT STRUCT_TYPE . option_formal_par inner_func_formal_par   (rule 202)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 176
    EXTERN	shift, and go to state 118
    MUL 	shift, and go to state 400
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    $default	reduce using rule 210 (option_formal_par)

    basic_exp	go to state 401
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 402
    option_formal_par	go to state 442
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 399

    func_formal_par  ->  VOID OPEN_PAR . unary_exp CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR inner_func_formal_par   (rule 203)
    func_formal_par  ->  VOID OPEN_PAR . unary_exp ARRAY CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR inner_func_formal_par   (rule 204)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    unary_exp	go to state 443
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 400

    option_formal_par  ->  MUL . option_formal_par   (rule 209)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 176
    EXTERN	shift, and go to state 118
    MUL 	shift, and go to state 400
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    $default	reduce using rule 210 (option_formal_par)

    basic_exp	go to state 401
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 402
    option_formal_par	go to state 444
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 401

    basic_exp  ->  basic_exp . DOT identifier   (rule 148)
    basic_exp  ->  basic_exp . IMPLY identifier   (rule 149)
    basic_exp  ->  basic_exp . OPEN_PAR func_actual_par CLOSE_PAR   (rule 150)
    basic_exp  ->  basic_exp . OPEN_MPAR exp option_exp CLOSE_MPAR   (rule 152)
    option_formal_par  ->  basic_exp . OPEN_MPAR exp option_exp CLOSE_MPAR   (rule 207)
    option_formal_par  ->  basic_exp . ARRAY   (rule 208)

    ARRAY	shift, and go to state 445
    DOT 	shift, and go to state 223
    OPEN_PAR	shift, and go to state 224
    OPEN_MPAR	shift, and go to state 446
    IMPLY	shift, and go to state 226



state 402

    primary_exp  ->  identifier .   (rule 154)
    option_formal_par  ->  identifier .   (rule 206)

    COLON	reduce using rule 206 (option_formal_par)
    CLOSE_PAR	reduce using rule 206 (option_formal_par)
    COMMA	reduce using rule 206 (option_formal_par)
    $default	reduce using rule 154 (primary_exp)



state 403

    func_formal_par  ->  STRUCT_TYPE option_formal_par . inner_func_formal_par   (rule 200)

    COMMA	shift, and go to state 250

    $default	reduce using rule 212 (inner_func_formal_par)

    inner_func_formal_par	go to state 447



state 404

    func_formal_par  ->  basic_type option_formal_par . inner_func_formal_par   (rule 199)

    COMMA	shift, and go to state 250

    $default	reduce using rule 212 (inner_func_formal_par)

    inner_func_formal_par	go to state 448



state 405

    statement  ->  EXIST identifier inner_func_formal_par COLON OPEN_BPAR . statement CLOSE_BPAR   (rule 61)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 449
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 406

    option_exp  ->  COMMA exp . option_exp   (rule 173)

    COMMA	shift, and go to state 346

    $default	reduce using rule 174 (option_exp)

    option_exp	go to state 450



state 407

    statement  ->  FRAME OPEN_PAR exp option_exp CLOSE_PAR . AND OPEN_PAR statement CLOSE_PAR   (rule 59)

    AND 	shift, and go to state 451



state 408

    bool_exp  ->  bool_exp . BOOL_OR logic_and_exp   (rule 107)
    for_sta_condition  ->  bool_exp .   (rule 228)

    BOOL_OR	shift, and go to state 202

    $default	reduce using rule 228 (for_sta_condition)



state 409

    extend_for_statement  ->  FOR OPEN_PAR for_sta_init COMMA for_sta_condition . COMMA for_sta_control CLOSE_PAR OPEN_BPAR statement CLOSE_BPAR   (rule 224)

    COMMA	shift, and go to state 452



state 410

    for_statement  ->  FOR ari_exp TIMES DO OPEN_BPAR . statement CLOSE_BPAR   (rule 223)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 453
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 411

    while_statement  ->  WHILE bool_par OPEN_BPAR statement CLOSE_BPAR .   (rule 221)

    $default	reduce using rule 221 (while_statement)



state 412

    do_while_statement  ->  DO OPEN_BPAR statement CLOSE_BPAR WHILE . bool_par   (rule 222)

    error	shift, and go to state 147
    OPEN_PAR	shift, and go to state 148

    bool_par	go to state 454



state 413

    statement  ->  REPEAT OPEN_BPAR statement CLOSE_BPAR UNTIL . OPEN_PAR bool_exp CLOSE_PAR   (rule 56)

    OPEN_PAR	shift, and go to state 455



state 414

    output_statement  ->  DISPLAY OPEN_PAR exp option_exp CLOSE_PAR .   (rule 235)

    $default	reduce using rule 235 (output_statement)



state 415

    declaration  ->  VOID OPEN_PAR unary_exp CLOSE_PAR OPEN_PAR . func_formal_par CLOSE_PAR   (rule 83)

    STRUCT	shift, and go to state 340
    FILEDEC	shift, and go to state 28
    VOID	shift, and go to state 341
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    STRUCT_TYPE	shift, and go to state 342

    $default	reduce using rule 205 (func_formal_par)

    basic_type	go to state 343
    windows_type	go to state 99
    func_formal_par	go to state 456



state 416

    type_cast  ->  OPEN_PAR VOID OPEN_PAR pointer CLOSE_PAR . OPEN_PAR func_formal_par CLOSE_PAR CLOSE_PAR   (rule 170)

    OPEN_PAR	shift, and go to state 457



state 417

    leftpart_4prj  ->  OPEN_PAR statement CLOSE_PAR XOR . ari_exp   (rule 65)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    ari_exp	go to state 458
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 418

    optional_leftpart_4prj  ->  COMMA leftpart_4prj . optional_leftpart_4prj   (rule 68)

    COMMA	shift, and go to state 362

    $default	reduce using rule 67 (optional_leftpart_4prj)

    optional_leftpart_4prj	go to state 459



state 419

    leftpart_4prj  ->  OPEN_PAR leftpart_4prj optional_leftpart_4prj CLOSE_PAR . XOR ari_exp   (rule 66)

    XOR 	shift, and go to state 460



state 420

    optional_projection  ->  COMMA leftpart_4prj optional_projection .   (rule 70)

    $default	reduce using rule 70 (optional_projection)



state 421

    statement  ->  OPEN_BPAR leftpart_4prj optional_projection CLOSE_BPAR PROJECTION . OPEN_BPAR statement CLOSE_BPAR   (rule 60)

    OPEN_BPAR	shift, and go to state 461



state 422

    statement  ->  FUNCTION ID OPEN_PAR func_formal_par CLOSE_PAR . OPEN_BPAR statement CLOSE_BPAR   (rule 62)

    OPEN_BPAR	shift, and go to state 462



state 423

    unary_exp  ->  SIZEOF OPEN_PAR STRUCT_TYPE pointer CLOSE_PAR .   (rule 143)

    $default	reduce using rule 143 (unary_exp)



state 424

    unary_exp  ->  SIZEOF OPEN_PAR basic_type pointer CLOSE_PAR .   (rule 141)

    $default	reduce using rule 141 (unary_exp)



state 425

    statement  ->  EXTERN FUNCTION ID OPEN_PAR func_formal_par . CLOSE_PAR   (rule 36)

    CLOSE_PAR	shift, and go to state 463



state 426

    input_statement  ->  REQUEST OPEN_PAR exp option_exp CLOSE_PAR .   (rule 236)

    $default	reduce using rule 236 (input_statement)



state 427

    option_declaration  ->  OPEN_PAR MUL identifier CLOSE_PAR . OPEN_MPAR exp option_exp CLOSE_MPAR inner_option_declaration   (rule 93)

    OPEN_MPAR	shift, and go to state 464



state 428

    option_declaration  ->  identifier ARRAY ASS_P init_list . inner_option_declaration   (rule 88)

    COMMA	shift, and go to state 297

    COMMA	[reduce using rule 96 (inner_option_declaration)]
    $default	reduce using rule 96 (inner_option_declaration)

    inner_option_declaration	go to state 465



state 429

    option_declaration  ->  identifier ARRAY ASS_P strliteral . inner_option_declaration   (rule 89)

    COMMA	shift, and go to state 297

    COMMA	[reduce using rule 96 (inner_option_declaration)]
    $default	reduce using rule 96 (inner_option_declaration)

    inner_option_declaration	go to state 466



state 430

    option_declaration  ->  identifier OPEN_MPAR exp option_exp . CLOSE_MPAR inner_option_declaration   (rule 85)
    option_declaration  ->  identifier OPEN_MPAR exp option_exp . CLOSE_MPAR ASS_P init_list inner_option_declaration   (rule 90)
    option_declaration  ->  identifier OPEN_MPAR exp option_exp . CLOSE_MPAR ASS_P strliteral inner_option_declaration   (rule 91)

    CLOSE_MPAR	shift, and go to state 467



state 431

    init_exp  ->  init_list . option_init_exp   (rule 99)

    COMMA	shift, and go to state 468

    $default	reduce using rule 101 (option_init_exp)

    option_init_exp	go to state 469



state 432

    init_list  ->  OPEN_BPAR init_exp . CLOSE_BPAR   (rule 97)

    CLOSE_BPAR	shift, and go to state 470



state 433

    init_exp  ->  bool_exp . option_init_exp   (rule 98)
    bool_exp  ->  bool_exp . BOOL_OR logic_and_exp   (rule 107)

    COMMA	shift, and go to state 468
    BOOL_OR	shift, and go to state 202

    $default	reduce using rule 101 (option_init_exp)

    option_init_exp	go to state 471



state 434

    option_declaration  ->  identifier ASS_P init_list inner_option_declaration .   (rule 87)

    $default	reduce using rule 87 (option_declaration)



state 435

    option_declaration  ->  identifier ASS_P bool_exp inner_option_declaration .   (rule 86)

    $default	reduce using rule 86 (option_declaration)



state 436

    option_struct_declaration  ->  declaration AND option_struct_declaration .   (rule 74)

    $default	reduce using rule 74 (option_struct_declaration)



state 437

    basic_exp  ->  basic_exp OPEN_MPAR exp option_exp CLOSE_MPAR .   (rule 152)

    $default	reduce using rule 152 (basic_exp)



state 438

    complexProposition  ->  OPEN_BPAR complexProposition poptional_projection CLOSE_BPAR PROJECTION OPEN_BPAR . complexProposition CLOSE_BPAR   (rule 22)

    EMPTY	shift, and go to state 3
    DEFINE	shift, and go to state 4
    MY_TRUE	shift, and go to state 5
    MY_FALSE	shift, and go to state 6
    SKIP	shift, and go to state 7
    OPEN_PAR	shift, and go to state 8
    OPEN_BPAR	shift, and go to state 9
    NEXT	shift, and go to state 10
    NEGATION	shift, and go to state 11
    LENGTH	shift, and go to state 12
    FINAL	shift, and go to state 13
    KEEP	shift, and go to state 14
    ALWAYS	shift, and go to state 15
    HALT	shift, and go to state 16
    W_NEXT	shift, and go to state 17
    SOMETIMES	shift, and go to state 18
    ID  	shift, and go to state 19

    complexProposition	go to state 472



state 439

    if_statement  ->  IF exp THEN OPEN_BPAR statement CLOSE_BPAR . option_else_statement   (rule 232)

    ELSE	shift, and go to state 473

    $default	reduce using rule 234 (option_else_statement)

    option_else_statement	go to state 474



state 440

    primary_exp  ->  IF exp THEN exp ELSE exp .   (rule 156)

    $default	reduce using rule 156 (primary_exp)



state 441

    func_formal_par  ->  STRUCT ID option_formal_par . inner_func_formal_par   (rule 201)

    COMMA	shift, and go to state 250

    $default	reduce using rule 212 (inner_func_formal_par)

    inner_func_formal_par	go to state 475



state 442

    func_formal_par  ->  STRUCT STRUCT_TYPE option_formal_par . inner_func_formal_par   (rule 202)

    COMMA	shift, and go to state 250

    $default	reduce using rule 212 (inner_func_formal_par)

    inner_func_formal_par	go to state 476



state 443

    func_formal_par  ->  VOID OPEN_PAR unary_exp . CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR inner_func_formal_par   (rule 203)
    func_formal_par  ->  VOID OPEN_PAR unary_exp . ARRAY CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR inner_func_formal_par   (rule 204)

    ARRAY	shift, and go to state 477
    CLOSE_PAR	shift, and go to state 478



state 444

    option_formal_par  ->  MUL option_formal_par .   (rule 209)

    $default	reduce using rule 209 (option_formal_par)



state 445

    option_formal_par  ->  basic_exp ARRAY .   (rule 208)

    $default	reduce using rule 208 (option_formal_par)



state 446

    basic_exp  ->  basic_exp OPEN_MPAR . exp option_exp CLOSE_MPAR   (rule 152)
    option_formal_par  ->  basic_exp OPEN_MPAR . exp option_exp CLOSE_MPAR   (rule 207)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    exp 	go to state 479
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 447

    func_formal_par  ->  STRUCT_TYPE option_formal_par inner_func_formal_par .   (rule 200)

    $default	reduce using rule 200 (func_formal_par)



state 448

    func_formal_par  ->  basic_type option_formal_par inner_func_formal_par .   (rule 199)

    $default	reduce using rule 199 (func_formal_par)



state 449

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)
    statement  ->  EXIST identifier inner_func_formal_par COLON OPEN_BPAR statement . CLOSE_BPAR   (rule 61)

    ARRAY	shift, and go to state 196
    CLOSE_BPAR	shift, and go to state 480
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200



state 450

    option_exp  ->  COMMA exp option_exp .   (rule 173)

    $default	reduce using rule 173 (option_exp)



state 451

    statement  ->  FRAME OPEN_PAR exp option_exp CLOSE_PAR AND . OPEN_PAR statement CLOSE_PAR   (rule 59)

    OPEN_PAR	shift, and go to state 481



state 452

    extend_for_statement  ->  FOR OPEN_PAR for_sta_init COMMA for_sta_condition COMMA . for_sta_control CLOSE_PAR OPEN_BPAR statement CLOSE_BPAR   (rule 224)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    $default	reduce using rule 231 (for_sta_control)

    ass_statement	go to state 482
    unary_exp	go to state 483
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    for_sta_control	go to state 484



state 453

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)
    for_statement  ->  FOR ari_exp TIMES DO OPEN_BPAR statement . CLOSE_BPAR   (rule 223)

    ARRAY	shift, and go to state 196
    CLOSE_BPAR	shift, and go to state 485
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200



state 454

    do_while_statement  ->  DO OPEN_BPAR statement CLOSE_BPAR WHILE bool_par .   (rule 222)

    $default	reduce using rule 222 (do_while_statement)



state 455

    statement  ->  REPEAT OPEN_BPAR statement CLOSE_BPAR UNTIL OPEN_PAR . bool_exp CLOSE_PAR   (rule 56)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    bool_exp	go to state 486
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 456

    declaration  ->  VOID OPEN_PAR unary_exp CLOSE_PAR OPEN_PAR func_formal_par . CLOSE_PAR   (rule 83)

    CLOSE_PAR	shift, and go to state 487



state 457

    type_cast  ->  OPEN_PAR VOID OPEN_PAR pointer CLOSE_PAR OPEN_PAR . func_formal_par CLOSE_PAR CLOSE_PAR   (rule 170)

    STRUCT	shift, and go to state 340
    FILEDEC	shift, and go to state 28
    VOID	shift, and go to state 341
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    STRUCT_TYPE	shift, and go to state 342

    $default	reduce using rule 205 (func_formal_par)

    basic_type	go to state 343
    windows_type	go to state 99
    func_formal_par	go to state 488



state 458

    leftpart_4prj  ->  OPEN_PAR statement CLOSE_PAR XOR ari_exp .   (rule 65)
    ari_exp  ->  ari_exp . LST add_exp   (rule 125)
    ari_exp  ->  ari_exp . RST add_exp   (rule 126)

    LST 	shift, and go to state 213
    RST 	shift, and go to state 214

    $default	reduce using rule 65 (leftpart_4prj)



state 459

    optional_leftpart_4prj  ->  COMMA leftpart_4prj optional_leftpart_4prj .   (rule 68)

    $default	reduce using rule 68 (optional_leftpart_4prj)



state 460

    leftpart_4prj  ->  OPEN_PAR leftpart_4prj optional_leftpart_4prj CLOSE_PAR XOR . ari_exp   (rule 66)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    ari_exp	go to state 489
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 461

    statement  ->  OPEN_BPAR leftpart_4prj optional_projection CLOSE_BPAR PROJECTION OPEN_BPAR . statement CLOSE_BPAR   (rule 60)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 490
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 462

    statement  ->  FUNCTION ID OPEN_PAR func_formal_par CLOSE_PAR OPEN_BPAR . statement CLOSE_BPAR   (rule 62)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 491
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 463

    statement  ->  EXTERN FUNCTION ID OPEN_PAR func_formal_par CLOSE_PAR .   (rule 36)

    $default	reduce using rule 36 (statement)



state 464

    option_declaration  ->  OPEN_PAR MUL identifier CLOSE_PAR OPEN_MPAR . exp option_exp CLOSE_MPAR inner_option_declaration   (rule 93)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    exp 	go to state 492
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 465

    option_declaration  ->  identifier ARRAY ASS_P init_list inner_option_declaration .   (rule 88)

    $default	reduce using rule 88 (option_declaration)



state 466

    option_declaration  ->  identifier ARRAY ASS_P strliteral inner_option_declaration .   (rule 89)

    $default	reduce using rule 89 (option_declaration)



state 467

    option_declaration  ->  identifier OPEN_MPAR exp option_exp CLOSE_MPAR . inner_option_declaration   (rule 85)
    option_declaration  ->  identifier OPEN_MPAR exp option_exp CLOSE_MPAR . ASS_P init_list inner_option_declaration   (rule 90)
    option_declaration  ->  identifier OPEN_MPAR exp option_exp CLOSE_MPAR . ASS_P strliteral inner_option_declaration   (rule 91)

    COMMA	shift, and go to state 297
    ASS_P	shift, and go to state 493

    COMMA	[reduce using rule 96 (inner_option_declaration)]
    $default	reduce using rule 96 (inner_option_declaration)

    inner_option_declaration	go to state 494



state 468

    option_init_exp  ->  COMMA . init_exp   (rule 100)

    IF  	shift, and go to state 116
    POINTERNULL	shift, and go to state 25
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    OPEN_PAR	shift, and go to state 117
    OPEN_BPAR	shift, and go to state 385
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 118
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 119
    NEGATION	shift, and go to state 64
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    init_list	go to state 431
    init_exp	go to state 495
    bool_exp	go to state 433
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 121
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103



state 469

    init_exp  ->  init_list option_init_exp .   (rule 99)

    $default	reduce using rule 99 (init_exp)



state 470

    init_list  ->  OPEN_BPAR init_exp CLOSE_BPAR .   (rule 97)

    $default	reduce using rule 97 (init_list)



state 471

    init_exp  ->  bool_exp option_init_exp .   (rule 98)

    $default	reduce using rule 98 (init_exp)



state 472

    complexProposition  ->  complexProposition . AND complexProposition   (rule 4)
    complexProposition  ->  complexProposition . OR complexProposition   (rule 5)
    complexProposition  ->  complexProposition . IFF complexProposition   (rule 6)
    complexProposition  ->  complexProposition . PROPIMPLY complexProposition   (rule 7)
    complexProposition  ->  complexProposition . CHOP complexProposition   (rule 8)
    complexProposition  ->  OPEN_BPAR complexProposition poptional_projection CLOSE_BPAR PROJECTION OPEN_BPAR complexProposition . CLOSE_BPAR   (rule 22)
    complexProposition  ->  complexProposition . CHOPSTAR   (rule 25)

    CLOSE_BPAR	shift, and go to state 496
    CHOP	shift, and go to state 129
    OR  	shift, and go to state 130
    AND 	shift, and go to state 131
    IFF 	shift, and go to state 132
    PROPIMPLY	shift, and go to state 133
    CHOPSTAR	shift, and go to state 134



state 473

    option_else_statement  ->  ELSE . OPEN_BPAR statement CLOSE_BPAR   (rule 233)

    OPEN_BPAR	shift, and go to state 497



state 474

    if_statement  ->  IF exp THEN OPEN_BPAR statement CLOSE_BPAR option_else_statement .   (rule 232)

    $default	reduce using rule 232 (if_statement)



state 475

    func_formal_par  ->  STRUCT ID option_formal_par inner_func_formal_par .   (rule 201)

    $default	reduce using rule 201 (func_formal_par)



state 476

    func_formal_par  ->  STRUCT STRUCT_TYPE option_formal_par inner_func_formal_par .   (rule 202)

    $default	reduce using rule 202 (func_formal_par)



state 477

    func_formal_par  ->  VOID OPEN_PAR unary_exp ARRAY . CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR inner_func_formal_par   (rule 204)

    CLOSE_PAR	shift, and go to state 498



state 478

    func_formal_par  ->  VOID OPEN_PAR unary_exp CLOSE_PAR . OPEN_PAR func_formal_par CLOSE_PAR inner_func_formal_par   (rule 203)

    OPEN_PAR	shift, and go to state 499



state 479

    basic_exp  ->  basic_exp OPEN_MPAR exp . option_exp CLOSE_MPAR   (rule 152)
    option_formal_par  ->  basic_exp OPEN_MPAR exp . option_exp CLOSE_MPAR   (rule 207)

    COMMA	shift, and go to state 346

    $default	reduce using rule 174 (option_exp)

    option_exp	go to state 500



state 480

    statement  ->  EXIST identifier inner_func_formal_par COLON OPEN_BPAR statement CLOSE_BPAR .   (rule 61)

    $default	reduce using rule 61 (statement)



state 481

    statement  ->  FRAME OPEN_PAR exp option_exp CLOSE_PAR AND OPEN_PAR . statement CLOSE_PAR   (rule 59)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 501
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 482

    for_sta_control  ->  ass_statement .   (rule 230)

    $default	reduce using rule 230 (for_sta_control)



state 483

    ass_statement  ->  unary_exp . assign_operator exp   (rule 102)

    ASS_P	shift, and go to state 220
    ASS_N	shift, and go to state 221

    assign_operator	go to state 222



state 484

    extend_for_statement  ->  FOR OPEN_PAR for_sta_init COMMA for_sta_condition COMMA for_sta_control . CLOSE_PAR OPEN_BPAR statement CLOSE_BPAR   (rule 224)

    CLOSE_PAR	shift, and go to state 502



state 485

    for_statement  ->  FOR ari_exp TIMES DO OPEN_BPAR statement CLOSE_BPAR .   (rule 223)

    $default	reduce using rule 223 (for_statement)



state 486

    statement  ->  REPEAT OPEN_BPAR statement CLOSE_BPAR UNTIL OPEN_PAR bool_exp . CLOSE_PAR   (rule 56)
    bool_exp  ->  bool_exp . BOOL_OR logic_and_exp   (rule 107)

    CLOSE_PAR	shift, and go to state 503
    BOOL_OR	shift, and go to state 202



state 487

    declaration  ->  VOID OPEN_PAR unary_exp CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR .   (rule 83)

    $default	reduce using rule 83 (declaration)



state 488

    type_cast  ->  OPEN_PAR VOID OPEN_PAR pointer CLOSE_PAR OPEN_PAR func_formal_par . CLOSE_PAR CLOSE_PAR   (rule 170)

    CLOSE_PAR	shift, and go to state 504



state 489

    leftpart_4prj  ->  OPEN_PAR leftpart_4prj optional_leftpart_4prj CLOSE_PAR XOR ari_exp .   (rule 66)
    ari_exp  ->  ari_exp . LST add_exp   (rule 125)
    ari_exp  ->  ari_exp . RST add_exp   (rule 126)

    LST 	shift, and go to state 213
    RST 	shift, and go to state 214

    $default	reduce using rule 66 (leftpart_4prj)



state 490

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)
    statement  ->  OPEN_BPAR leftpart_4prj optional_projection CLOSE_BPAR PROJECTION OPEN_BPAR statement . CLOSE_BPAR   (rule 60)

    ARRAY	shift, and go to state 196
    CLOSE_BPAR	shift, and go to state 505
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200



state 491

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)
    statement  ->  FUNCTION ID OPEN_PAR func_formal_par CLOSE_PAR OPEN_BPAR statement . CLOSE_BPAR   (rule 62)

    ARRAY	shift, and go to state 196
    CLOSE_BPAR	shift, and go to state 506
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200



state 492

    option_declaration  ->  OPEN_PAR MUL identifier CLOSE_PAR OPEN_MPAR exp . option_exp CLOSE_MPAR inner_option_declaration   (rule 93)

    COMMA	shift, and go to state 346

    $default	reduce using rule 174 (option_exp)

    option_exp	go to state 507



state 493

    option_declaration  ->  identifier OPEN_MPAR exp option_exp CLOSE_MPAR ASS_P . init_list inner_option_declaration   (rule 90)
    option_declaration  ->  identifier OPEN_MPAR exp option_exp CLOSE_MPAR ASS_P . strliteral inner_option_declaration   (rule 91)

    OPEN_BPAR	shift, and go to state 385
    STRLITERAL	shift, and go to state 71

    init_list	go to state 508
    strliteral	go to state 509



state 494

    option_declaration  ->  identifier OPEN_MPAR exp option_exp CLOSE_MPAR inner_option_declaration .   (rule 85)

    $default	reduce using rule 85 (option_declaration)



state 495

    option_init_exp  ->  COMMA init_exp .   (rule 100)

    $default	reduce using rule 100 (option_init_exp)



state 496

    complexProposition  ->  OPEN_BPAR complexProposition poptional_projection CLOSE_BPAR PROJECTION OPEN_BPAR complexProposition CLOSE_BPAR .   (rule 22)

    $default	reduce using rule 22 (complexProposition)



state 497

    option_else_statement  ->  ELSE OPEN_BPAR . statement CLOSE_BPAR   (rule 233)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 510
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 498

    func_formal_par  ->  VOID OPEN_PAR unary_exp ARRAY CLOSE_PAR . OPEN_PAR func_formal_par CLOSE_PAR inner_func_formal_par   (rule 204)

    OPEN_PAR	shift, and go to state 511



state 499

    func_formal_par  ->  VOID OPEN_PAR unary_exp CLOSE_PAR OPEN_PAR . func_formal_par CLOSE_PAR inner_func_formal_par   (rule 203)

    STRUCT	shift, and go to state 340
    FILEDEC	shift, and go to state 28
    VOID	shift, and go to state 341
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    STRUCT_TYPE	shift, and go to state 342

    $default	reduce using rule 205 (func_formal_par)

    basic_type	go to state 343
    windows_type	go to state 99
    func_formal_par	go to state 512



state 500

    basic_exp  ->  basic_exp OPEN_MPAR exp option_exp . CLOSE_MPAR   (rule 152)
    option_formal_par  ->  basic_exp OPEN_MPAR exp option_exp . CLOSE_MPAR   (rule 207)

    CLOSE_MPAR	shift, and go to state 513



state 501

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)
    statement  ->  FRAME OPEN_PAR exp option_exp CLOSE_PAR AND OPEN_PAR statement . CLOSE_PAR   (rule 59)

    ARRAY	shift, and go to state 196
    CLOSE_PAR	shift, and go to state 514
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200



state 502

    extend_for_statement  ->  FOR OPEN_PAR for_sta_init COMMA for_sta_condition COMMA for_sta_control CLOSE_PAR . OPEN_BPAR statement CLOSE_BPAR   (rule 224)

    OPEN_BPAR	shift, and go to state 515



state 503

    statement  ->  REPEAT OPEN_BPAR statement CLOSE_BPAR UNTIL OPEN_PAR bool_exp CLOSE_PAR .   (rule 56)

    $default	reduce using rule 56 (statement)



state 504

    type_cast  ->  OPEN_PAR VOID OPEN_PAR pointer CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR . CLOSE_PAR   (rule 170)

    CLOSE_PAR	shift, and go to state 516



state 505

    statement  ->  OPEN_BPAR leftpart_4prj optional_projection CLOSE_BPAR PROJECTION OPEN_BPAR statement CLOSE_BPAR .   (rule 60)

    $default	reduce using rule 60 (statement)



state 506

    statement  ->  FUNCTION ID OPEN_PAR func_formal_par CLOSE_PAR OPEN_BPAR statement CLOSE_BPAR .   (rule 62)

    $default	reduce using rule 62 (statement)



state 507

    option_declaration  ->  OPEN_PAR MUL identifier CLOSE_PAR OPEN_MPAR exp option_exp . CLOSE_MPAR inner_option_declaration   (rule 93)

    CLOSE_MPAR	shift, and go to state 517



state 508

    option_declaration  ->  identifier OPEN_MPAR exp option_exp CLOSE_MPAR ASS_P init_list . inner_option_declaration   (rule 90)

    COMMA	shift, and go to state 297

    COMMA	[reduce using rule 96 (inner_option_declaration)]
    $default	reduce using rule 96 (inner_option_declaration)

    inner_option_declaration	go to state 518



state 509

    option_declaration  ->  identifier OPEN_MPAR exp option_exp CLOSE_MPAR ASS_P strliteral . inner_option_declaration   (rule 91)

    COMMA	shift, and go to state 297

    COMMA	[reduce using rule 96 (inner_option_declaration)]
    $default	reduce using rule 96 (inner_option_declaration)

    inner_option_declaration	go to state 519



state 510

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)
    option_else_statement  ->  ELSE OPEN_BPAR statement . CLOSE_BPAR   (rule 233)

    ARRAY	shift, and go to state 196
    CLOSE_BPAR	shift, and go to state 520
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200



state 511

    func_formal_par  ->  VOID OPEN_PAR unary_exp ARRAY CLOSE_PAR OPEN_PAR . func_formal_par CLOSE_PAR inner_func_formal_par   (rule 204)

    STRUCT	shift, and go to state 340
    FILEDEC	shift, and go to state 28
    VOID	shift, and go to state 341
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    STRUCT_TYPE	shift, and go to state 342

    $default	reduce using rule 205 (func_formal_par)

    basic_type	go to state 343
    windows_type	go to state 99
    func_formal_par	go to state 521



state 512

    func_formal_par  ->  VOID OPEN_PAR unary_exp CLOSE_PAR OPEN_PAR func_formal_par . CLOSE_PAR inner_func_formal_par   (rule 203)

    CLOSE_PAR	shift, and go to state 522



state 513

    basic_exp  ->  basic_exp OPEN_MPAR exp option_exp CLOSE_MPAR .   (rule 152)
    option_formal_par  ->  basic_exp OPEN_MPAR exp option_exp CLOSE_MPAR .   (rule 207)

    COLON	reduce using rule 207 (option_formal_par)
    CLOSE_PAR	reduce using rule 207 (option_formal_par)
    COMMA	reduce using rule 207 (option_formal_par)
    $default	reduce using rule 152 (basic_exp)



state 514

    statement  ->  FRAME OPEN_PAR exp option_exp CLOSE_PAR AND OPEN_PAR statement CLOSE_PAR .   (rule 59)

    $default	reduce using rule 59 (statement)



state 515

    extend_for_statement  ->  FOR OPEN_PAR for_sta_init COMMA for_sta_condition COMMA for_sta_control CLOSE_PAR OPEN_BPAR . statement CLOSE_BPAR   (rule 224)

    INCLUDE	shift, and go to state 21
    IF  	shift, and go to state 22
    EMPTY	shift, and go to state 23
    AWAIT	shift, and go to state 24
    POINTERNULL	shift, and go to state 25
    STRUCT	shift, and go to state 26
    UNION	shift, and go to state 27
    FILEDEC	shift, and go to state 28
    MY_TRUE	shift, and go to state 29
    MY_FALSE	shift, and go to state 30
    EXIST	shift, and go to state 31
    FRAME	shift, and go to state 32
    FOR 	shift, and go to state 33
    WHILE	shift, and go to state 34
    DO  	shift, and go to state 35
    TRUE	shift, and go to state 36
    FALSE	shift, and go to state 37
    REPEAT	shift, and go to state 38
    DISPLAY	shift, and go to state 39
    SKIP	shift, and go to state 40
    VOID	shift, and go to state 41
    BOOL	shift, and go to state 42
    CHAR	shift, and go to state 43
    SHORT	shift, and go to state 44
    INT 	shift, and go to state 45
    LONG	shift, and go to state 46
    STR 	shift, and go to state 47
    FLOAT	shift, and go to state 48
    DOUBLE	shift, and go to state 49
    CRITICAL_SECTION	shift, and go to state 50
    TIMECAPS	shift, and go to state 51
    OPEN_PAR	shift, and go to state 52
    OPEN_BPAR	shift, and go to state 53
    FUNCTION	shift, and go to state 54
    UNSIGNED	shift, and go to state 55
    SIGNED	shift, and go to state 56
    SIZEOF	shift, and go to state 57
    EXTERN	shift, and go to state 58
    ADDRESS	shift, and go to state 59
    SUB 	shift, and go to state 60
    MUL 	shift, and go to state 61
    BNE 	shift, and go to state 62
    NEXT	shift, and go to state 63
    NEGATION	shift, and go to state 64
    LENGTH	shift, and go to state 65
    REQUEST	shift, and go to state 66
    FINAL	shift, and go to state 67
    KEEP	shift, and go to state 68
    ALWAYS	shift, and go to state 69
    ID  	shift, and go to state 70
    STRLITERAL	shift, and go to state 71
    STRUCT_TYPE	shift, and go to state 72
    INTLITERAL	shift, and go to state 73
    FLOATLITERAL	shift, and go to state 74
    CHARLITERAL	shift, and go to state 75

    statement	go to state 523
    struct_define_statement	go to state 77
    struct_identifier	go to state 78
    declaration	go to state 79
    ass_statement	go to state 80
    exp 	go to state 81
    bool_exp	go to state 82
    logic_and_exp	go to state 83
    bit_or_exp	go to state 84
    bit_xor_exp	go to state 85
    bit_and_exp	go to state 86
    equlity_exp	go to state 87
    relation_exp	go to state 88
    ari_exp	go to state 89
    add_exp	go to state 90
    mul_exp	go to state 91
    unary_exp	go to state 92
    basic_exp	go to state 93
    primary_exp	go to state 94
    const_exp	go to state 95
    identifier	go to state 96
    type_cast	go to state 97
    basic_type	go to state 98
    windows_type	go to state 99
    strliteral	go to state 100
    intliteral	go to state 101
    charliteral	go to state 102
    floatliteral	go to state 103
    while_statement	go to state 104
    do_while_statement	go to state 105
    for_statement	go to state 106
    extend_for_statement	go to state 107
    if_statement	go to state 108
    output_statement	go to state 109
    input_statement	go to state 110



state 516

    type_cast  ->  OPEN_PAR VOID OPEN_PAR pointer CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR CLOSE_PAR .   (rule 170)

    $default	reduce using rule 170 (type_cast)



state 517

    option_declaration  ->  OPEN_PAR MUL identifier CLOSE_PAR OPEN_MPAR exp option_exp CLOSE_MPAR . inner_option_declaration   (rule 93)

    COMMA	shift, and go to state 297

    COMMA	[reduce using rule 96 (inner_option_declaration)]
    $default	reduce using rule 96 (inner_option_declaration)

    inner_option_declaration	go to state 524



state 518

    option_declaration  ->  identifier OPEN_MPAR exp option_exp CLOSE_MPAR ASS_P init_list inner_option_declaration .   (rule 90)

    $default	reduce using rule 90 (option_declaration)



state 519

    option_declaration  ->  identifier OPEN_MPAR exp option_exp CLOSE_MPAR ASS_P strliteral inner_option_declaration .   (rule 91)

    $default	reduce using rule 91 (option_declaration)



state 520

    option_else_statement  ->  ELSE OPEN_BPAR statement CLOSE_BPAR .   (rule 233)

    $default	reduce using rule 233 (option_else_statement)



state 521

    func_formal_par  ->  VOID OPEN_PAR unary_exp ARRAY CLOSE_PAR OPEN_PAR func_formal_par . CLOSE_PAR inner_func_formal_par   (rule 204)

    CLOSE_PAR	shift, and go to state 525



state 522

    func_formal_par  ->  VOID OPEN_PAR unary_exp CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR . inner_func_formal_par   (rule 203)

    COMMA	shift, and go to state 250

    $default	reduce using rule 212 (inner_func_formal_par)

    inner_func_formal_par	go to state 526



state 523

    statement  ->  statement . AND statement   (rule 29)
    statement  ->  statement . OR statement   (rule 30)
    statement  ->  statement . ARRAY statement   (rule 31)
    statement  ->  statement . PARALLEL statement   (rule 32)
    statement  ->  statement . CHOP statement   (rule 33)
    extend_for_statement  ->  FOR OPEN_PAR for_sta_init COMMA for_sta_condition COMMA for_sta_control CLOSE_PAR OPEN_BPAR statement . CLOSE_BPAR   (rule 224)

    ARRAY	shift, and go to state 196
    CLOSE_BPAR	shift, and go to state 527
    CHOP	shift, and go to state 197
    OR  	shift, and go to state 198
    PARALLEL	shift, and go to state 199
    AND 	shift, and go to state 200



state 524

    option_declaration  ->  OPEN_PAR MUL identifier CLOSE_PAR OPEN_MPAR exp option_exp CLOSE_MPAR inner_option_declaration .   (rule 93)

    $default	reduce using rule 93 (option_declaration)



state 525

    func_formal_par  ->  VOID OPEN_PAR unary_exp ARRAY CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR . inner_func_formal_par   (rule 204)

    COMMA	shift, and go to state 250

    $default	reduce using rule 212 (inner_func_formal_par)

    inner_func_formal_par	go to state 528



state 526

    func_formal_par  ->  VOID OPEN_PAR unary_exp CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR inner_func_formal_par .   (rule 203)

    $default	reduce using rule 203 (func_formal_par)



state 527

    extend_for_statement  ->  FOR OPEN_PAR for_sta_init COMMA for_sta_condition COMMA for_sta_control CLOSE_PAR OPEN_BPAR statement CLOSE_BPAR .   (rule 224)

    $default	reduce using rule 224 (extend_for_statement)



state 528

    func_formal_par  ->  VOID OPEN_PAR unary_exp ARRAY CLOSE_PAR OPEN_PAR func_formal_par CLOSE_PAR inner_func_formal_par .   (rule 204)

    $default	reduce using rule 204 (func_formal_par)



state 529

    $   	go to state 530



state 530

    $   	go to state 531



state 531

    $default	accept
